# 1. 操作系统漫游

## 1.1 信息就是位＋上下文

​	hello程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。

## 1. 2 程序被其他程序翻译成不同的格式

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```c
linux> gcc -o hello hello.c 
```

![](https://pic.imgdb.cn/item/618fd5aa2ab3f51d9172e0bb.jpg)



## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![](https://pic.imgdb.cn/item/618fd60f2ab3f51d91730b08.jpg)

​	初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串"./hello"后，shell程序将字符逐一读入寄存器，再把它存放到内存中，如图1-5所示。

​	当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串"hello,world\n"。

## 1.6 存储设备形成层次结构

![](https://pic.imgdb.cn/item/618fd6cf2ab3f51d9173476a.jpg)

## 1.7 进程

![](https://pic.imgdb.cn/item/618fd7ac2ab3f51d91739a23.jpg)

### 1.7.3 虚拟内存

​	虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

![](https://pic.imgdb.cn/item/618fd7f32ab3f51d9173bb85.jpg)

## 1. 9 重要主题

### 1.9.1 Amdahl定律

![](https://pic.imgdb.cn/item/618fd8722ab3f51d917445b0.jpg)

### 1.9.2 并发和并行



![](https://pic.imgdb.cn/item/618fd9532ab3f51d917501e2.jpg)

### 1. 9. 3 计算机系统中抽象的重要性

![](https://pic.imgdb.cn/item/618fd9902ab3f51d91753222.jpg)

# 2. 信息的表示和处理

## 2.1 信息存储

### 2. 1. 3 寻址和字节顺序

![](https://pic.imgdb.cn/item/618fdb7d2ab3f51d91769cf6.jpg)

​	前一种规则——最低有效字节在最前面的方式，称为小端法(littleendian)。后一种规则—-—最高有效字节在最前面的方式，称为大端法(bigendian)。

## 2.2 整数表示

​	图2 - 8 列出了我们引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。这些术语将在描述的过程中介绍，图在此处列出作为参考。

![](https://pic.imgdb.cn/item/6190c51d2ab3f51d91be8f5c.jpg)



### 2.2.3 补码编码

 ![](https://pic.imgdb.cn/item/6190c6122ab3f51d91bedcaa.jpg)

### 2. 2. 4 有符号数和无符号数之间的转换

![](https://pic.imgdb.cn/item/6190c6862ab3f51d91befecc.jpg)

​	对于大多数C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![](https://pic.imgdb.cn/item/6190c6c52ab3f51d91bf1597.jpg)





![](https://pic.imgdb.cn/item/6190c7232ab3f51d91bf3422.jpg)

### 2 . 2 . 6 扩展一个数字的位表示

![](https://pic.imgdb.cn/item/6190ce422ab3f51d91c173b3.jpg)

### 2. 2. 7 截断数字

![](https://pic.imgdb.cn/item/6190cee22ab3f51d91c19dc1.jpg)

![](https://pic.imgdb.cn/item/6190d0492ab3f51d91c20c02.jpg)

## 2. 3 整数运算

### 2.3.1 无符号加法

![](https://pic.imgdb.cn/item/6191130f2ab3f51d91d52c3f.jpg)

![](https://pic.imgdb.cn/item/6191135d2ab3f51d91d5447e.jpg)

### 2.3.2 补码加法

![](https://pic.imgdb.cn/item/619113e62ab3f51d91d56982.jpg)

![](https://pic.imgdb.cn/item/619113fe2ab3f51d91d57186.jpg)

### 2.3.3 补码的非

![](https://pic.imgdb.cn/item/6191156a2ab3f51d91d5d615.jpg)

### 2.3.4 无符号乘法

![](https://pic.imgdb.cn/item/619116102ab3f51d91d5fdbb.jpg)

### 2.3.5 补码乘法

![](https://pic.imgdb.cn/item/6191163f2ab3f51d91d60864.jpg)

### 2.3.6 乘以常数

![](https://pic.imgdb.cn/item/61911a192ab3f51d91d73316.jpg)



### 2.3.7 除以2的幂

![](https://pic.imgdb.cn/item/619250442ab3f51d91348acb.jpg)



![](https://pic.imgdb.cn/item/619250b82ab3f51d9134abec.jpg)

![](https://pic.imgdb.cn/item/619251b52ab3f51d9134fd08.jpg)

## 2.4 浮点数

### 2.4.1 二进制小数

![](https://pic.imgdb.cn/item/619254232ab3f51d9135bc35.jpg)

### 2.4.2 IEEE浮点表示

![](https://pic.imgdb.cn/item/619255ca2ab3f51d91362a7a.jpg)

![](https://pic.imgdb.cn/item/619256522ab3f51d9136538e.jpg)

![](https://pic.imgdb.cn/item/619256e52ab3f51d913680a8.jpg)

![](https://pic.imgdb.cn/item/619257032ab3f51d91368817.jpg)

### 2.4.3 数字示例

![](https://pic.imgdb.cn/item/619257c82ab3f51d9136c1e8.jpg)

### 2.4.4 舍入

​	IEEE 浮点格式定义了四种不同的舍入方式 。默认的方法是找到最接近的匹配，而其他三种可用 于计算上界和下界。

![](https://pic.imgdb.cn/item/61925a2b2ab3f51d91378e48.jpg)

### 2.4.5 浮点运算

​	略。

### 家庭作业 todo



# 3. 程序的机器级表示

## 3.1 历史观点

​	8086(1978 年， 29K 个晶体管）。它是第一代单芯片、16 位微处理器之一。8088 是8086的一个变种，在8086 上增加了一个8 位外部总线，构成最初的IBM 个人计算机的心脏。

![](https://pic.imgdb.cn/item/6193a0342ab3f51d91a5f765.jpg)

## 3.2 程序编码

### 3.2.1 机器级代码

略

### 3.2.2 代码示例

![](https://pic.imgdb.cn/item/6193a2b92ab3f51d91a7523a.jpg)

![](https://pic.imgdb.cn/item/6193a3262ab3f51d91a782c8.jpg)

其中一些关千机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从1 到15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx 是以字节值53 开头的。
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
* 反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q' 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call 和ret 指令添加了'q'后缀，同样，省略这些后缀也没有问题。

### 3.2.3 关于格式的注解

![](https://pic.imgdb.cn/item/6193a4b12ab3f51d91a84a9b.jpg)

![](https://pic.imgdb.cn/item/6193a4cd2ab3f51d91a864e5.jpg)

## 3.3 数据格式

![](https://pic.imgdb.cn/item/6193a4fc2ab3f51d91a8939f.jpg)

## 3.4 访问信息

​	一个x86-64 的中央处理单元(CPU) 包含一组16 个存储64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

![](https://pic.imgdb.cn/item/6193a5ed2ab3f51d91a91683.jpg)

​	如图3-2 中嵌套的方框标明的，指令可以对这16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节， 16 位操作可以访问最低的2 个字节， 32 位操作可以访问最低的4 个字节，而64 位操作可以访问整个寄存器。

### 3.4.1 操作数指示符

​	大多数指令有一个或多个操作数(operand), 指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

​	第一种类型是立即数(immediate) , 用来表示常数值。在ATT 格式的汇编代码中，立即数的书写方式是'$'后面跟一个用标准C 表示法表示的整数，比如，'$-577' 或'$0x1F'。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器(register) , 它表示某个寄存器的内容， 16 个寄存器的低位1 字节、2 字节、4 字节或8 字节中的一个作为操作数，这些字节数分别对应于8 位、16 位、32 位或64 位。在图3 - 3 中，我们用符号ra 来表示任意寄存器a, 用引用R[ra ] 来表示它的值，这是将寄存器集合看成一个数组R, 用寄存器标识符作为索引。

![](https://pic.imgdb.cn/item/6193a7832ab3f51d91a9e364.jpg)

![](https://pic.imgdb.cn/item/6193a7902ab3f51d91a9e904.jpg)

![](https://pic.imgdb.cn/item/6193a7e92ab3f51d91aa0e78.jpg)

### 3.4.2 数据传送指令

![](https://pic.imgdb.cn/item/6193aba72ab3f51d91ac2b0b.jpg)

![](https://pic.imgdb.cn/item/6193abbd2ab3f51d91ac3368.jpg)

![](https://pic.imgdb.cn/item/6193acaf2ab3f51d91ac92ed.jpg)

### 3.4.3 数据传送示例

![](https://pic.imgdb.cn/item/6193aef12ab3f51d91ad9550.jpg)

### 3.4.4 压入和弹出栈

![](https://pic.imgdb.cn/item/6193b0772ab3f51d91ae21ed.jpg)

![](https://pic.imgdb.cn/item/6193b0a52ab3f51d91ae2f46.jpg)

## 3.5 算术和逻辑操作

