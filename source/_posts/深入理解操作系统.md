# 1. 操作系统漫游

## 1.1 信息就是位＋上下文

​	hello程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。

## 1. 2 程序被其他程序翻译成不同的格式

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```c
linux> gcc -o hello hello.c 
```

![](https://pic.imgdb.cn/item/618fd5aa2ab3f51d9172e0bb.jpg)



## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![](https://pic.imgdb.cn/item/618fd60f2ab3f51d91730b08.jpg)

​	初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串"./hello"后，shell程序将字符逐一读入寄存器，再把它存放到内存中，如图1-5所示。

​	当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串"hello,world\n"。

## 1.6 存储设备形成层次结构

![](https://pic.imgdb.cn/item/618fd6cf2ab3f51d9173476a.jpg)

## 1.7 进程

![](https://pic.imgdb.cn/item/618fd7ac2ab3f51d91739a23.jpg)

### 1.7.3 虚拟内存

​	虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

![](https://pic.imgdb.cn/item/618fd7f32ab3f51d9173bb85.jpg)

## 1. 9 重要主题

### 1.9.1 Amdahl定律

![](https://pic.imgdb.cn/item/618fd8722ab3f51d917445b0.jpg)

### 1.9.2 并发和并行



![](https://pic.imgdb.cn/item/618fd9532ab3f51d917501e2.jpg)

### 1. 9. 3 计算机系统中抽象的重要性

![](https://pic.imgdb.cn/item/618fd9902ab3f51d91753222.jpg)

# 2. 信息的表示和处理

## 2.1 信息存储

### 2. 1. 3 寻址和字节顺序

![](https://pic.imgdb.cn/item/618fdb7d2ab3f51d91769cf6.jpg)

​	前一种规则——最低有效字节在最前面的方式，称为小端法(littleendian)。后一种规则—-—最高有效字节在最前面的方式，称为大端法(bigendian)。

## 2.2 整数表示

​	图2 - 8 列出了我们引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。这些术语将在描述的过程中介绍，图在此处列出作为参考。

![](https://pic.imgdb.cn/item/6190c51d2ab3f51d91be8f5c.jpg)



### 2.2.3 补码编码

 ![](https://pic.imgdb.cn/item/6190c6122ab3f51d91bedcaa.jpg)

### 2. 2. 4 有符号数和无符号数之间的转换

![](https://pic.imgdb.cn/item/6190c6862ab3f51d91befecc.jpg)

​	对于大多数C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![](https://pic.imgdb.cn/item/6190c6c52ab3f51d91bf1597.jpg)





![](https://pic.imgdb.cn/item/6190c7232ab3f51d91bf3422.jpg)

### 2 . 2 . 6 扩展一个数字的位表示

![](https://pic.imgdb.cn/item/6190ce422ab3f51d91c173b3.jpg)

### 2. 2. 7 截断数字

![](https://pic.imgdb.cn/item/6190cee22ab3f51d91c19dc1.jpg)

![](https://pic.imgdb.cn/item/6190d0492ab3f51d91c20c02.jpg)

## 2. 3 整数运算

### 2.3.1 无符号加法

![](https://pic.imgdb.cn/item/6191130f2ab3f51d91d52c3f.jpg)

![](https://pic.imgdb.cn/item/6191135d2ab3f51d91d5447e.jpg)

### 2.3.2 补码加法

![](https://pic.imgdb.cn/item/619113e62ab3f51d91d56982.jpg)

![](https://pic.imgdb.cn/item/619113fe2ab3f51d91d57186.jpg)

### 2.3.3 补码的非

![](https://pic.imgdb.cn/item/6191156a2ab3f51d91d5d615.jpg)

### 2.3.4 无符号乘法

![](https://pic.imgdb.cn/item/619116102ab3f51d91d5fdbb.jpg)

### 2.3.5 补码乘法

![](https://pic.imgdb.cn/item/6191163f2ab3f51d91d60864.jpg)

### 2.3.6 乘以常数

![](https://pic.imgdb.cn/item/61911a192ab3f51d91d73316.jpg)



### 2.3.7 除以2的幂

![](https://pic.imgdb.cn/item/619250442ab3f51d91348acb.jpg)



![](https://pic.imgdb.cn/item/619250b82ab3f51d9134abec.jpg)

![](https://pic.imgdb.cn/item/619251b52ab3f51d9134fd08.jpg)

## 2.4 浮点数

### 2.4.1 二进制小数

![](https://pic.imgdb.cn/item/619254232ab3f51d9135bc35.jpg)

### 2.4.2 IEEE浮点表示

![](https://pic.imgdb.cn/item/619255ca2ab3f51d91362a7a.jpg)

![](https://pic.imgdb.cn/item/619256522ab3f51d9136538e.jpg)

![](https://pic.imgdb.cn/item/619256e52ab3f51d913680a8.jpg)

![](https://pic.imgdb.cn/item/619257032ab3f51d91368817.jpg)

### 2.4.3 数字示例

![](https://pic.imgdb.cn/item/619257c82ab3f51d9136c1e8.jpg)

### 2.4.4 舍入

​	IEEE 浮点格式定义了四种不同的舍入方式 。默认的方法是找到最接近的匹配，而其他三种可用 于计算上界和下界。

![](https://pic.imgdb.cn/item/61925a2b2ab3f51d91378e48.jpg)

### 2.4.5 浮点运算

​	略。

## 练习题

### 练习题2.1 

完成下面的数字转换：

A. 将0x39A7F8 转换为二进制。

0011 1001 1010 0111 1111 1000

B. 将二进制1100 1001 0111 1011 转换为十六进制。

0xC97B

C. 将0xD5E4C 转换为二进制。

1101 0101 1110 0100 1100

D. 将二进制10 0110 1110 0111 1011 0101 转换为十六进制。

0x26E7B5

### 练习题2.2

填写下表中的空白项，给出2 的不同次幕的二进制和十六进制表示：

| n    | 2^n(十进制) | 2^n(十六进制) |
| ---- | ----------- | ------------- |
| 9    | 512         | 0x200         |
| 19   | 262144      | 0x 4 0000     |
| 14   | 16 384      | 0x 4000       |
| 16   | 65536       | 0x 1 0000     |
| 17   | 131 072     | 0x 2 0000     |
| 5    | 32          | 0x 20         |
| 7    | 128         | 0x 80         |

### 练习题2.3

​	一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值：

| 十进制 | 二进制      | 十六进制 |
| ------ | ----------- | -------- |
| 0      | 0           | 0x00     |
| 167    | 0x1010 0111 | 0xA7     |
| 62     |             | 0x       |
| 188    |             |          |
|        | 0011 0111   |          |
|        | 1000 1000   |          |
|        | 1111 0011   |          |
|        |             | 0x52     |
|        |             | 0xAC     |
|        |             | 0xE7     |



## 家庭作业 todo



# 3. 程序的机器级表示

## 3.1 历史观点

​	8086(1978 年， 29K 个晶体管）。它是第一代单芯片、16 位微处理器之一。8088 是8086的一个变种，在8086 上增加了一个8 位外部总线，构成最初的IBM 个人计算机的心脏。

![](https://pic.imgdb.cn/item/6193a0342ab3f51d91a5f765.jpg)

## 3.2 程序编码

### 3.2.1 机器级代码

略

### 3.2.2 代码示例

![](https://pic.imgdb.cn/item/6193a2b92ab3f51d91a7523a.jpg)

![](https://pic.imgdb.cn/item/6193a3262ab3f51d91a782c8.jpg)

其中一些关千机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从1 到15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx 是以字节值53 开头的。
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
* 反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q' 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call 和ret 指令添加了'q'后缀，同样，省略这些后缀也没有问题。

### 3.2.3 关于格式的注解

![](https://pic.imgdb.cn/item/6193a4b12ab3f51d91a84a9b.jpg)

![](https://pic.imgdb.cn/item/6193a4cd2ab3f51d91a864e5.jpg)

## 3.3 数据格式

![](https://pic.imgdb.cn/item/6193a4fc2ab3f51d91a8939f.jpg)

## 3.4 访问信息

​	一个x86-64 的中央处理单元(CPU) 包含一组16 个存储64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

![](https://pic.imgdb.cn/item/6193a5ed2ab3f51d91a91683.jpg)

​	如图3-2 中嵌套的方框标明的，指令可以对这16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节， 16 位操作可以访问最低的2 个字节， 32 位操作可以访问最低的4 个字节，而64 位操作可以访问整个寄存器。

### 3.4.1 操作数指示符

​	大多数指令有一个或多个操作数(operand), 指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

​	第一种类型是立即数(immediate) , 用来表示常数值。在ATT 格式的汇编代码中，立即数的书写方式是'$'后面跟一个用标准C 表示法表示的整数，比如，'$-577' 或'$0x1F'。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器(register) , 它表示某个寄存器的内容， 16 个寄存器的低位1 字节、2 字节、4 字节或8 字节中的一个作为操作数，这些字节数分别对应于8 位、16 位、32 位或64 位。在图3 - 3 中，我们用符号ra 来表示任意寄存器a, 用引用R[ra ] 来表示它的值，这是将寄存器集合看成一个数组R, 用寄存器标识符作为索引。

![](https://pic.imgdb.cn/item/6193a7832ab3f51d91a9e364.jpg)

![](https://pic.imgdb.cn/item/6193a7902ab3f51d91a9e904.jpg)

![](https://pic.imgdb.cn/item/6193a7e92ab3f51d91aa0e78.jpg)

### 3.4.2 数据传送指令

![](https://pic.imgdb.cn/item/6193aba72ab3f51d91ac2b0b.jpg)

![](https://pic.imgdb.cn/item/6193abbd2ab3f51d91ac3368.jpg)

![](https://pic.imgdb.cn/item/6193acaf2ab3f51d91ac92ed.jpg)

### 3.4.3 数据传送示例

![](https://pic.imgdb.cn/item/6193aef12ab3f51d91ad9550.jpg)

### 3.4.4 压入和弹出栈

![](https://pic.imgdb.cn/item/6193b0772ab3f51d91ae21ed.jpg)

![](https://pic.imgdb.cn/item/6193b0a52ab3f51d91ae2f46.jpg)

## 3.5 算术和逻辑操作

​	操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与3.4 节中所讲的一样。

![](https://pic.imgdb.cn/item/619a253b2ab3f51d9112e8f4.jpg)

### 3.5.1 加载有效地址

​	加栽有效地址Ooad effective address) 指令leaq 实际上是movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![](https://pic.imgdb.cn/item/619a25a52ab3f51d9113099d.jpg)

### 3.5.2 一元和二元操作

![](https://pic.imgdb.cn/item/619a26042ab3f51d91132d1a.jpg)

### 3.5.3 移位操作

![](https://pic.imgdb.cn/item/619a264e2ab3f51d91134c08.jpg)

### 3.5.4 讨论

![](https://pic.imgdb.cn/item/619a27cb2ab3f51d9113e50a.jpg)

### 3.5.5 特殊的算术操作

![](https://pic.imgdb.cn/item/619a28c52ab3f51d91144599.jpg)

## 3.6 控制

### 3.6.1 条件码

![](https://pic.imgdb.cn/item/619a34e82ab3f51d9119dd5b.jpg)

![](https://pic.imgdb.cn/item/619a35152ab3f51d9119fc4c.jpg)

### 3.6.2 访问条件码

​	条件码通常不会直接读取，常用的使用方法有三种： 1) 可以根据条件码的某种组合，将一个字节设置为0 或者1, 2) 可以条件跳转到程序的某个其他的部分， 3) 可以有条件地传送数据。

![](https://pic.imgdb.cn/item/619a35892ab3f51d911a2eec.jpg)

![](https://pic.imgdb.cn/item/619a35982ab3f51d911a3a1b.jpg)

### 3.6.3 跳转指令

​	正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转(jump) 指令会导致执行切换到程序中一个全新的位置。

![](https://pic.imgdb.cn/item/619a37412ab3f51d911ae64d.jpg)

![](https://pic.imgdb.cn/item/619a37572ab3f51d911af163.jpg)

### 3.6.4 跳转指令的编码

​	在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是PC 相对的(PC-relative) 。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1 、2 或4 个字节。第二种编码方法是给出“绝对“地址，用4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

![](https://pic.imgdb.cn/item/619a37e72ab3f51d911b2d79.jpg)

### 3.6.5 用条件控制来实现条件分支

![](https://pic.imgdb.cn/item/619a38e42ab3f51d911b91dc.jpg)

### 3.6.6 用条件传送来实现条件分支

​	实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。

​	一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。我们将介绍这一策略，以及它在x86-64 上的实现。

![](https://pic.imgdb.cn/item/619a398d2ab3f51d911bd3b7.jpg)

​	为了理解为什么基千条件数据传送的代码会比基千条件控制转移的代码（如图3-16 中那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第4章和第5 章中看到的，处理器通过使用流水线(pipelinin g) 来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器） 。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支")时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费大约15~30 个时钟周期，导致程序性能严重下降。

### 3.6.7 循环

### ![](https://pic.imgdb.cn/item/619a3ad12ab3f51d911c5f66.jpg)

### 3.6.8 switch语句

![](https://pic.imgdb.cn/item/619a3fbd2ab3f51d911e4622.jpg)

![](https://pic.imgdb.cn/item/619a3bf92ab3f51d911cce63.jpg)

## 3.7 过程

​	不同编程语言中，过程的形式多样：函数(function) 、方法(method) 、子例程(subroutine) 、处理函数(handler) 等等，但是它们有一些共有的特性。

​	要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程p 调用过程Q, Q 执行后返回到P 。这些动作包括下面一个或多个机制：

​	传递控制。在进入过程Q 的时候，程序计数器必须被设置为Q 的代码的起始地址，然后在返回时，要把程序计数器设置为P 中调用Q 后面那条指令的地址。传递数据。P 必须能够向Q 提供一个或多个参数， Q 必须能够向P 返回一个值。分配和释放内存。在开始时， Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

### 3.7.1 运行时栈

![](https://pic.imgdb.cn/item/619b87502ab3f51d919bc8ad.jpg)

​	C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程P 调用过程Q的例子中，可以看到当Q 在执行时， p 以及所有在向上追溯到P 的调用链中的过程，都是暂时被挂起的。当Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当Q 返回时，任何它所分配的局部存地址增大储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P 调用Q 时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。

### 3.7.2 转移控制

​	将控制从函数P 转移到函数Q 只需要简单地把程序计数器(PC ) 设置为Q 的代码的起始位置。不过， 当稍后从Q 返回的时候，处理器必须记录好它需要继续P 的执行的代码位置。在x86 -6 4 机器中，这个信息是用指令c all Q 调用过程Q 来记录的。该指令会把地址A 压入栈中，并将PC 设置为Q 的起始地址。压入的地址A 被称为返回地址，是紧跟在call 指令后面的那条指令的地址。对应的指令ret 会从栈中弹出地址A, 并把PC 设置为A 。

![](https://pic.imgdb.cn/item/619b8a552ab3f51d919db6e1.jpg)

### 3.7.3 数据传送

​	当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64 中，大部分过程间的数据传送是通过寄存器实现的。例如，我们已经看到无数的函数示例，参数在寄存器% rdi 、% rsi ;和其他寄存器中传递。当过程P 调用过程Q 时， P 的代码必须首先把参数复制到适当的寄存器中。类似地，当Q 返回到P 时， P 的代码可以访问寄存器% rax中的返回值。在本节中，我们更详细地探讨这些规则。

### 3.7.4 栈上的局部存储

​	到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不
过有些时候，局部数据必须存放在内存中，常见的情况包括：

* 寄存器不足够存放所有的本地数据。
* 对一个局部变蜇使用地址运算符＇＆＇，因此必须能够为它产生一个地址。
* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述
  数组和结构分配时，我们会讨论这个问题。

### 3.7.5 寄存器中的局部存储空间

​	寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此， x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

### 3.7.6 递归过程

​	前面已经描述的寄存器和栈的惯例使得x86-64 过程能够递归地调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

## 3.8 数组分配和访问

​	C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。

### 3.8.1 基本原则

```
T A[N];
```

​	起始位置表示为环。这个声明有两个效果。首先，它在内存中分配一个L• N 字节的连续区域，这里L 是数据类型T 的大小（单位为字节）。其次，它引入了标识符A, 可以用A 来作为指向数组开头的指针，这个指针的值就是环。可以用O~N-1 的整数索引来访问该数组元素。数组元素z 会被存放在地址为XA+L * i 的地方。

### 3.8.2 指针运算

![](https://pic.imgdb.cn/item/619b8df72ab3f51d91a01d60.jpg)

### 3.8.3 嵌套的数组

![](https://pic.imgdb.cn/item/619b8eb42ab3f51d91a0868c.jpg)

### 3.8.4 定长数组

![](https://pic.imgdb.cn/item/619b8f8b2ab3f51d91a10331.jpg)

### 3.8.5 变长数组

​	历史上， C 语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。程序员需要变长数组时不得不用malloc 或calloc 这样的函数为这些数组分配存储空间，而且不得不显式地编码，用行优先索引将多维数组映射到一维数组，如公式(3. 1) 所示。ISOC吵引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。

## 3.9 异质的数据结构

### 3.9.1 结构

​	C 语言的struct 声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似千数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（如Id) 的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

### 3.9.2 联合

​	联合提供了一种方式，能够规避C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

![](https://pic.imgdb.cn/item/619b918d2ab3f51d91a2153d.jpg)

### 3.9.3 数据对齐

​	许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K( 通常是2 、4 或8) 的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取8 个字节，则地址必须为8的倍数。如果我们能保证将所有的double 类型数据的地址对齐成8 的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8 字节内存块中。

![](https://pic.imgdb.cn/item/619b92af2ab3f51d91a27ff3.jpg)



## 3.10 在机器级程序中将控制与数据结合起来

### 3.10 .1 理解指针

* 每个指针都对应一个类型。
* 每个指针都有一个值。
* 指针用'&'运算符创建。
* *操作符用于间接引用指针。
* 数组与指针紧密联系。
* 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
* 指针也可以指向函数。

### 3.10.2 应用: 使用GDB调试器



![](https://pic.imgdb.cn/item/619c53082ab3f51d91e37416.jpg)

![](https://pic.imgdb.cn/item/619c53ab2ab3f51d91e3b129.jpg)

### 3.10.3 内存越界引用和缓冲区溢出

​	我们已经看到， C 对数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret 指令时，就会出现很严重的错误。

​	一种特别常见的状态破坏称为缓冲区溢出(buffer overflow) 。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。下面这个程序示例就说明了这个问题：

![](https://pic.imgdb.cn/item/619c54152ab3f51d91e3d789.jpg)

​	缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code), 另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret 指令的效果就是跳转到攻击代码。

​	在一种攻击形式中，攻击代码会使用系统调用启动一个shell 程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret 指令，（表面上）正常返回到调用者。

​	让我们来看一个例子，在1988 年11 月，著名的Internet 蠕虫病毒通过Internet 以四种不同的方法获取对许多计算机的访问。一种是对finger 守护进程fingerd 的缓冲区溢出攻击， fingerd 服务FINGER 命令请求。通过以一个适当的字符串调用FINGER, 蠕虫可以使远程的守护进程缓冲区溢出并执行一段代码，让蠕虫访问远程系统。一旦蠕虫获得了对系统的访问，它就能自我复制，几乎完全地消耗掉机器上所有的计算资源。结果，在安全专家制定出如何消除这种蠕虫的方法之前，成百上千的机器实际上都瘫痪了。这种蠕虫的始作桶者最后被抓住并被起诉。时至今日，人们还是不断地发现遭受缓冲区溢出攻击的系统安全漏洞，这更加突显了仔细编写程序的必要性。任何到外部环境的接口都应该是“防弹的＂，这样，外部代理的行为才不会导致系统出现错误。

### 3.10.4 对抗缓冲区溢出攻击

​	缓冲区溢出攻击的普遍发生给计算机系统造成了许多的麻烦。现代的编译器和操作系统实现了很多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。在本节中，我们会介绍一些Linux 上最新GCC 版本所提供的机制。

**1.栈随机化**

​	为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，如果攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象常被称作安全单一化(security monoculture) [ 96] 。

​	栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段0~ n 字节之间的随机大小的空间，例如，使用分配函数alloca 在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范围n 必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。

​	在Linux 系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化(Addr ess-Space Layout Randomization), 或者简称ASLR[99] 。采用ASLR, 每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变最和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的攻击。

**2.栈破坏检测**

​	计算机的第二道防线是能够检测到何时栈已经被破坏。我们在echo 函数示例（图中看到，破坏通常发生在当超越局部缓冲区的边界时。在C 语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

![](https://pic.imgdb.cn/item/619c5abb2ab3f51d91e6fa36.jpg)

**3.限制可执行代码区域**

​	最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。

​	最近， AMD 为它的64 位处理器的内存保护引入了"NX" (No-Execute, 不执行）位，将读和执行访问模式分开， Intel 也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。

### 3.10.5 支持变长栈帧

​	到目前为止，我们已经检查了各种函数的机器级代码，但它们有一个共同点，即编译器能够预先确定需要为栈帧分配多少空间。但是有些函数，需要的局部存储是变长的。例如，当函数调用alloca 时就会发生这种情况。alloca 是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

​	为了管理变长栈帧， x86-64 代码使用寄存器%rbp 作为帧指针(frame pointer) (有时称为基指针(base pointer)。

​	在较早版本的x86 代码中，每个函数调用都使用了帧指针。而现在，只在栈帧长可变的情况下才使用，就像函数vframe 的情况一样。历史上，大多数编译器在生成IA32 代码时会使用帧指针。最近的GCC 版本放弃了这个惯例。可以看到把使用帧指针的代码和不使用帧指针的代码混在一起是可以的，只要所有的函数都把%rbp 当做被调用者保存寄存器来处理即可。

## 3.11 浮点代码

* 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
* 对浮点数据操作的指令。
* 向函数传递浮点数参数和从函数返回浮点数结果的规则。
* 函数调用过程中保存寄存器的规则例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。



​	AVX 浮点体系结构允许数据存储在16 个YMM 寄存器中，它们的名字为%ymrnO~ %ymrn 15 。每个YMM 寄存器都是256 位( 32 字节）。当对标最数据操作时，这些寄存器只保存浮点数，而且只使用低32 位（对千fl oa t) 或64 位（对于double) 。汇编代码用寄存器的SSE XMM 寄存器名字%x mrn0~ %xmrn15 来引用它们，每个XMM 寄存器都是对应的YMM 寄存器的低128 位(16 字节） 。

![](https://pic.imgdb.cn/item/619c5c6f2ab3f51d91e7fab3.jpg)

### 3.11.1 浮点传送和转换操作

​	图3-46 给出了一组在内存和XMM 寄存器之间以及从一个XMM 寄存器到另一个不做任何转换的传送浮点数的指令。引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中（由表中的M32 和MG. 指明），要么保存在XMM 寄存器中（在表中用X 表示）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议3 2 位内存数据满足4 字节对齐， 64 位数据满足8 字节对齐。内存引用的指定方式与整数MOV 指令的一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

![](https://pic.imgdb.cn/item/619c62092ab3f51d91ea7990.jpg)

​	GCC 只用标量传送操作从内存传送数据到XMM 寄存器或从XMM 寄存器传送数据到内存。对于在两个XMM 寄存器之间传送数据， GCC 会使用两种指令之一，即用vmovaps 传送单精度数，用vmovapd 传送双精度数。对于这些情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令没有实质上的差别。指令名字中的字母＇矿表示"ali gned( 对齐的）＂ 。当用于读写内存时，如果地址不满足16 字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。

![](https://pic.imgdb.cn/item/619c62682ab3f51d91ea9757.jpg)

![](https://pic.imgdb.cn/item/619c62cb2ab3f51d91eac081.jpg)

### 3.11.2 过程中的浮点代码

​	在x86-64 中， XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。如图3-45 所示，可以看到如下规则：

* XMM 寄存器%xmm0~ %xmm7 最多可以传递8 个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
* 函数使用寄存器%xmm0 来返回浮点值。
* 所有的XMM 寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

### 3.11.3 浮点运算操作

![](https://pic.imgdb.cn/item/619c63af2ab3f51d91eb2345.jpg)

### 3.11.4 定义和使用浮点常数

​	和整数运算操作不同， AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读入。下面从摄氏度到华氏度转换的函数就说明了这个问题：

![](https://pic.imgdb.cn/item/619c663a2ab3f51d91ecad4a.jpg)

### 3.11.5 在浮点代码中使用位级操作

​	有时，我们会发现GCC 生成的代码会在XMM 寄存器上执行位级操作，得到有用的浮点结果。图3 - 50 展示了一些相关的指令，类似千它们在通用寄存器上对应的操作。这些操作都作用于封装好的数据，即它们更新整个目的XMM 寄存器，对两个源寄存器的所有位都实施指定的位级操作。和前面一样，我们只对标量数据感兴趣， 只想了解这些指令对目的寄存器的低4 或8 字节的影响。从下面的例子中以看出，运用这些操作通常可以简单方便地操作浮点数。

![](https://pic.imgdb.cn/item/619d98622ab3f51d916514bc.jpg)

### 3.11.6 浮点比较操作

![](https://pic.imgdb.cn/item/619d98a62ab3f51d9165255c.jpg)

### 3.11.7 对浮点代码的观察结论

![](https://pic.imgdb.cn/item/619d991f2ab3f51d916543ba.jpg)

