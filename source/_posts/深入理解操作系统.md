# 1. 操作系统漫游

## 1.1 信息就是位＋上下文

​	hello程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。

## 1. 2 程序被其他程序翻译成不同的格式

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```c
linux> gcc -o hello hello.c 
```

![](https://pic.imgdb.cn/item/618fd5aa2ab3f51d9172e0bb.jpg)



## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![](https://pic.imgdb.cn/item/618fd60f2ab3f51d91730b08.jpg)

​	初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串"./hello"后，shell程序将字符逐一读入寄存器，再把它存放到内存中，如图1-5所示。

​	当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串"hello,world\n"。

## 1.6 存储设备形成层次结构

![](https://pic.imgdb.cn/item/618fd6cf2ab3f51d9173476a.jpg)

## 1.7 进程

![](https://pic.imgdb.cn/item/618fd7ac2ab3f51d91739a23.jpg)

### 1.7.3 虚拟内存

​	虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

![](https://pic.imgdb.cn/item/618fd7f32ab3f51d9173bb85.jpg)

## 1. 9 重要主题

### 1.9.1 Amdahl定律

![](https://pic.imgdb.cn/item/618fd8722ab3f51d917445b0.jpg)

### 1.9.2 并发和并行



![](https://pic.imgdb.cn/item/618fd9532ab3f51d917501e2.jpg)

### 1. 9. 3 计算机系统中抽象的重要性

![](https://pic.imgdb.cn/item/618fd9902ab3f51d91753222.jpg)

# 2. 信息的表示和处理

## 2.1 信息存储

### 2. 1. 3 寻址和字节顺序

![](https://pic.imgdb.cn/item/618fdb7d2ab3f51d91769cf6.jpg)

​	前一种规则——最低有效字节在最前面的方式，称为小端法(littleendian)。后一种规则—-—最高有效字节在最前面的方式，称为大端法(bigendian)。

## 2.2 整数表示

​	图2 - 8 列出了我们引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。这些术语将在描述的过程中介绍，图在此处列出作为参考。

![](https://pic.imgdb.cn/item/6190c51d2ab3f51d91be8f5c.jpg)



### 2.2.3 补码编码

 ![](https://pic.imgdb.cn/item/6190c6122ab3f51d91bedcaa.jpg)

### 2. 2. 4 有符号数和无符号数之间的转换

![](https://pic.imgdb.cn/item/6190c6862ab3f51d91befecc.jpg)

​	对于大多数C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

![](https://pic.imgdb.cn/item/6190c6c52ab3f51d91bf1597.jpg)





![](https://pic.imgdb.cn/item/6190c7232ab3f51d91bf3422.jpg)

### 2 . 2 . 6 扩展一个数字的位表示

![](https://pic.imgdb.cn/item/6190ce422ab3f51d91c173b3.jpg)

### 2. 2. 7 截断数字

![](https://pic.imgdb.cn/item/6190cee22ab3f51d91c19dc1.jpg)

![](https://pic.imgdb.cn/item/6190d0492ab3f51d91c20c02.jpg)

## 2. 3 整数运算

### 2.3.1 无符号加法

![](https://pic.imgdb.cn/item/6191130f2ab3f51d91d52c3f.jpg)

![](https://pic.imgdb.cn/item/6191135d2ab3f51d91d5447e.jpg)

### 2.3.2 补码加法

![](https://pic.imgdb.cn/item/619113e62ab3f51d91d56982.jpg)

![](https://pic.imgdb.cn/item/619113fe2ab3f51d91d57186.jpg)

### 2.3.3 补码的非

![](https://pic.imgdb.cn/item/6191156a2ab3f51d91d5d615.jpg)

### 2.3.4 无符号乘法

![](https://pic.imgdb.cn/item/619116102ab3f51d91d5fdbb.jpg)

### 2.3.5 补码乘法

![](https://pic.imgdb.cn/item/6191163f2ab3f51d91d60864.jpg)

### 2.3.6 乘以常数

![](https://pic.imgdb.cn/item/61911a192ab3f51d91d73316.jpg)



### 2.3.7 除以2的幂

![](https://pic.imgdb.cn/item/619250442ab3f51d91348acb.jpg)



![](https://pic.imgdb.cn/item/619250b82ab3f51d9134abec.jpg)

![](https://pic.imgdb.cn/item/619251b52ab3f51d9134fd08.jpg)

## 2.4 浮点数

### 2.4.1 二进制小数

![](https://pic.imgdb.cn/item/619254232ab3f51d9135bc35.jpg)

### 2.4.2 IEEE浮点表示

![](https://pic.imgdb.cn/item/619255ca2ab3f51d91362a7a.jpg)

![](https://pic.imgdb.cn/item/619256522ab3f51d9136538e.jpg)

![](https://pic.imgdb.cn/item/619256e52ab3f51d913680a8.jpg)

![](https://pic.imgdb.cn/item/619257032ab3f51d91368817.jpg)

### 2.4.3 数字示例

![](https://pic.imgdb.cn/item/619257c82ab3f51d9136c1e8.jpg)

### 2.4.4 舍入

​	IEEE 浮点格式定义了四种不同的舍入方式 。默认的方法是找到最接近的匹配，而其他三种可用 于计算上界和下界。

![](https://pic.imgdb.cn/item/61925a2b2ab3f51d91378e48.jpg)

### 2.4.5 浮点运算

​	略。

### 家庭作业 todo



# 3. 程序的机器级表示

## 3.1 历史观点

​	8086(1978 年， 29K 个晶体管）。它是第一代单芯片、16 位微处理器之一。8088 是8086的一个变种，在8086 上增加了一个8 位外部总线，构成最初的IBM 个人计算机的心脏。

![](https://pic.imgdb.cn/item/6193a0342ab3f51d91a5f765.jpg)

## 3.2 程序编码

### 3.2.1 机器级代码

略

### 3.2.2 代码示例

![](https://pic.imgdb.cn/item/6193a2b92ab3f51d91a7523a.jpg)

![](https://pic.imgdb.cn/item/6193a3262ab3f51d91a782c8.jpg)

其中一些关千机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从1 到15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx 是以字节值53 开头的。
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
* 反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q' 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call 和ret 指令添加了'q'后缀，同样，省略这些后缀也没有问题。

### 3.2.3 关于格式的注解

![](https://pic.imgdb.cn/item/6193a4b12ab3f51d91a84a9b.jpg)

![](https://pic.imgdb.cn/item/6193a4cd2ab3f51d91a864e5.jpg)

## 3.3 数据格式

![](https://pic.imgdb.cn/item/6193a4fc2ab3f51d91a8939f.jpg)

## 3.4 访问信息

​	一个x86-64 的中央处理单元(CPU) 包含一组16 个存储64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

![](https://pic.imgdb.cn/item/6193a5ed2ab3f51d91a91683.jpg)

​	如图3-2 中嵌套的方框标明的，指令可以对这16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节， 16 位操作可以访问最低的2 个字节， 32 位操作可以访问最低的4 个字节，而64 位操作可以访问整个寄存器。

### 3.4.1 操作数指示符

​	大多数指令有一个或多个操作数(operand), 指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

​	第一种类型是立即数(immediate) , 用来表示常数值。在ATT 格式的汇编代码中，立即数的书写方式是'$'后面跟一个用标准C 表示法表示的整数，比如，'$-577' 或'$0x1F'。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器(register) , 它表示某个寄存器的内容， 16 个寄存器的低位1 字节、2 字节、4 字节或8 字节中的一个作为操作数，这些字节数分别对应于8 位、16 位、32 位或64 位。在图3 - 3 中，我们用符号ra 来表示任意寄存器a, 用引用R[ra ] 来表示它的值，这是将寄存器集合看成一个数组R, 用寄存器标识符作为索引。

![](https://pic.imgdb.cn/item/6193a7832ab3f51d91a9e364.jpg)

![](https://pic.imgdb.cn/item/6193a7902ab3f51d91a9e904.jpg)

![](https://pic.imgdb.cn/item/6193a7e92ab3f51d91aa0e78.jpg)

### 3.4.2 数据传送指令

![](https://pic.imgdb.cn/item/6193aba72ab3f51d91ac2b0b.jpg)

![](https://pic.imgdb.cn/item/6193abbd2ab3f51d91ac3368.jpg)

![](https://pic.imgdb.cn/item/6193acaf2ab3f51d91ac92ed.jpg)

### 3.4.3 数据传送示例

![](https://pic.imgdb.cn/item/6193aef12ab3f51d91ad9550.jpg)

### 3.4.4 压入和弹出栈

![](https://pic.imgdb.cn/item/6193b0772ab3f51d91ae21ed.jpg)

![](https://pic.imgdb.cn/item/6193b0a52ab3f51d91ae2f46.jpg)

## 3.5 算术和逻辑操作

​	操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与3.4 节中所讲的一样。

![](https://pic.imgdb.cn/item/619a253b2ab3f51d9112e8f4.jpg)

### 3.5.1 加载有效地址

​	加栽有效地址Ooad effective address) 指令leaq 实际上是movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![](https://pic.imgdb.cn/item/619a25a52ab3f51d9113099d.jpg)

### 3.5.2 一元和二元操作

![](https://pic.imgdb.cn/item/619a26042ab3f51d91132d1a.jpg)

### 3.5.3 移位操作

![](https://pic.imgdb.cn/item/619a264e2ab3f51d91134c08.jpg)

### 3.5.4 讨论

![](https://pic.imgdb.cn/item/619a27cb2ab3f51d9113e50a.jpg)

### 3.5.5 特殊的算术操作

![](https://pic.imgdb.cn/item/619a28c52ab3f51d91144599.jpg)

## 3.6 控制

### 3.6.1 条件码

![](https://pic.imgdb.cn/item/619a34e82ab3f51d9119dd5b.jpg)

![](https://pic.imgdb.cn/item/619a35152ab3f51d9119fc4c.jpg)

### 3.6.2 访问条件码

​	条件码通常不会直接读取，常用的使用方法有三种： 1) 可以根据条件码的某种组合，将一个字节设置为0 或者1, 2) 可以条件跳转到程序的某个其他的部分， 3) 可以有条件地传送数据。

![](https://pic.imgdb.cn/item/619a35892ab3f51d911a2eec.jpg)

![](https://pic.imgdb.cn/item/619a35982ab3f51d911a3a1b.jpg)

### 3.6.3 跳转指令

​	正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转(jump) 指令会导致执行切换到程序中一个全新的位置。

![](https://pic.imgdb.cn/item/619a37412ab3f51d911ae64d.jpg)

![](https://pic.imgdb.cn/item/619a37572ab3f51d911af163.jpg)

### 3.6.4 跳转指令的编码

​	在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是PC 相对的(PC-relative) 。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1 、2 或4 个字节。第二种编码方法是给出“绝对“地址，用4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

![](https://pic.imgdb.cn/item/619a37e72ab3f51d911b2d79.jpg)

### 3.6.5 用条件控制来实现条件分支

![](https://pic.imgdb.cn/item/619a38e42ab3f51d911b91dc.jpg)

### 3.6.6 用条件传送来实现条件分支

​	实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。

​	一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。我们将介绍这一策略，以及它在x86-64 上的实现。

![](https://pic.imgdb.cn/item/619a398d2ab3f51d911bd3b7.jpg)

​	为了理解为什么基千条件数据传送的代码会比基千条件控制转移的代码（如图3-16 中那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第4章和第5 章中看到的，处理器通过使用流水线(pipelinin g) 来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器） 。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支")时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费大约15~30 个时钟周期，导致程序性能严重下降。

### 3.6.7 循环

### ![](https://pic.imgdb.cn/item/619a3ad12ab3f51d911c5f66.jpg)

### 3.6.8 switch语句

![](https://pic.imgdb.cn/item/619a3fbd2ab3f51d911e4622.jpg)

![](https://pic.imgdb.cn/item/619a3bf92ab3f51d911cce63.jpg)

## 3.7 过程

