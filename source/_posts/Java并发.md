# 并发级别

​	根据控制并发的策略，我们可以把并发的级别分为阻塞、无饥饿、无障碍、无锁、无等待几种。

* 阻塞
* 无饥饿
  * 对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，按照先来后到的规则，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队，这样所有的线程都有机会执行。
* 无障碍（Obstruction-Free）
  * 无障碍是一种最弱的非阻塞调度。两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起。换言之，大家都可以大摇大摆地进入临界区了。那么大家一起修改共享数据，把数据改坏了怎么办呢？对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。
  * 如果说阻塞的控制方式是悲观策略，也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此以保护共享数据为第一优先级，相对来说，非阻塞的调度就是一种乐观的策略。它认为多个线程之间很有可能不会发生冲突，或者说这种概率不大。因此大家都应该无障碍地执行，但是一旦检测到冲突，就应该进行回滚。
* 无锁（Lock-Free）
  * 无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。
  * 在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的，不至于全军覆没。至于临界区中竞争失败的线程，它们必须不断重试，直到自己获胜。如果运气很不好，总是尝试不成功，则会出现类似饥饿的现象，线程会停止。
* 无等待（Wait-Free）
  * 无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。如果限制这个步骤的上限，还可以进一步分解为有界无等待和线程数无关的无等待等几种，它们之间的区别只是对循环次数的限制不同。
  * 一种典型的无等待结构就是RCU（Read Copy Update）。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。

# Amdahl定律

阿姆达尔

​	加速比 = 优化前系统耗时 / 优化后系统耗时

​	所谓加速比就是优化前的耗时与优化后耗时的比值。加速比越高，表明优化效果越明显。图1.8显示了Amdahl公式的推导过程，其中n表示处理器个数，T表示时间，T1表示优化前耗时（也就是只有1个处理器时的耗时），Tn表示使用n个处理器优化后的耗时。F是程序中只能串行执行的比例。

![](https://pic.imgdb.cn/item/610aab135132923bf8cdfc4a.jpg)

# Gustafson定律

[ˈgʌstəfsən]

![](https://pic.imgdb.cn/item/610aab9c5132923bf8d07df8.jpg)

# JMM

* 原子性（Atomicity）
  * 原子性是指一个操作是不可中断的。
* 可见性（Visibility）
  * 可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。
* 有序性（Ordering）

# 线程&进程

* 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
* 线程就是轻量级进程，是程序执行的最小单位。使用多线程而不是用多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。

**线程生命周期**

![](https://pic.imgdb.cn/item/610b5d955132923bf87f8a16.jpg)

## 线程启动

```java
	@Test
    public void newTread() {
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println("111");
            }
        };
        thread.start();
    }
```

## 终止线程

* 线程Thread提供了一个stop()方法。如果你使用stop()方法，就可以立即将一个线程终止，非常方便。但如果你使用Eclipse之类的IDE写代码，就会发现stop()方法是一个被标注为废弃的方法。也就是说，在将来，JDK可能就会移除该方法。
  * 为什么stop()方法被废弃而不推荐使用呢？原因是stop()方法过于暴力，强行把执行到一半的线程终止，可能会引起一些数据不一致的问题。
  * Thread.stop()方法在结束线程时，会直接终止线程，并立即释放这个线程所持有的锁，而这些锁恰恰是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经被释放，另外一个等待该锁的读线程就顺理成章地读到了这个不一致的对象，悲剧也就此发生。整个过程如图2.4所示。

![](https://pic.imgdb.cn/item/610b60c45132923bf888ac00.jpg)



​	如果需要停止一个线程，那么应该怎么做呢？其实方法很简单，只需要由我们自行决定线程何时退出就可以了。仍然用本例说明，只需要将ChangeObjectThread线程增加一个stopMe()方法即可。

![](https://pic.imgdb.cn/item/610b611d5132923bf88979bf.jpg)

## 线程中断

* stop()方法停止线程的坏处，并且使用了一套自有的机制完善线程退出的功能。在JDK中是否有提供更强大的支持呢？答案是肯定的，那就是线程中断。

![](https://pic.imgdb.cn/item/610b614e5132923bf889ebbb.jpg)

​	Thread.interrupt()方法是一个实例方法。它通知目标线程中断，也就是设置中断标志位。中断标志位表示当前线程已经被中断了。Thread.isInterrupted()方法也是实例方法，它判断当前线程是否被中断（通过检查中断标志位）。最后的静态方法Thread.interrupted()也可用来判断当前线程的中断状态，但同时会清除当前线程的中断标志位状态。

​	下面这段代码对t1线程进行了中断，那么中断后t1会停止执行吗？

![](https://pic.imgdb.cn/item/610b624c5132923bf88c3caa.jpg)

​	在这里，虽然对t1进行了中断，但是在t1中并没有中断处理的逻辑，因此，即使t1线程被置为中断状态，这个中断也不会发生任何作用。

​	如果希望t1在中断后退出，就必须为它增加相应的中断处理代码：

![](https://pic.imgdb.cn/item/610b625f5132923bf88c703d.jpg)

​	Thread.sleep()方法会让当前线程休眠若干时间，它会抛出一个InterruptedException中断异常。InterruptedException不是运行时异常，也就是说程序必须捕获并且处理它，当线程在sleep()休眠时，如果被中断，这个异常就会产生。

![](https://pic.imgdb.cn/item/610b628e5132923bf88cf125.jpg)

​	注意上面代码中第10～15行，如果线程在第11行代码处被中断，则程序会抛出异常，并进入第13行代码处理。在catch子句部分，由于已经捕获了中断，我们可以立即退出线程。但在这里，我们并没有这么做，因为也许在这段代码中，我们还必须进行后续的处理来保证数据的一致性和完整性，因此，执行了Thread.interrupt()方法再次中断自己，置上中断标记位。只有这么做，在第6行代码的中断检查中，才能发现当前线程已经被中断了。

​	注意：Thread.sleep()方法由于中断而抛出异常，此时，它会清除中断标记，如果不加处理，那么在下一次循环开始时，就无法捕获这个中断，故在异常处理中，再次设置中断标记位。

## 等待（wait）和通知（notify）

* 等待wait()
* 通知notify()



​	当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思呢？比如，在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到何时结束呢？线程A会一直等到其他线程调用了obj.notify()方法为止。这时，object对象俨然成了多个线程之间的有效通信手段。

​	如果一个线程调用了object.wait()方法，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个等待队列中随机选择一个线程，并将其唤醒。这里希望大家注意的是，这个选择是不公平的，并不是先等待的线程就会优先被选择，这个选择完全是随机的。

![](https://pic.imgdb.cn/item/610b79085132923bf8cdc35e.jpg)

​	除notify()方法外，Object对象还有一个类似的notifyAll()方法，它和notify()方法的功能基本一致，不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。

​	这里还需要强调一点，Object.wait()方法并不能随便调用。它必须包含在对应的synchronzied语句中，无论是wait()方法或者notify()方法都需要首先获得目标对象的一个监视器。图2.6显示了wait()方法和notify()方法的工作流程细节。其中T1和T2表示两个线程。T1在正确执行wait()方法前，必须获得object对象的监视器。而wait()方法在执行后，会释放这个监视器。这样做的目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法正常执行。

​	线程T2在notify()方法调用前，也必须获得object对象的监视器。所幸，此时T1已经释放了这个监视器。因此，T2可以顺利获得object对象的监视器。接着，T2执行了notify()方法尝试唤醒一个等待线程，这里假设唤醒了T1。T1在被唤醒后，要做的第一件事并不是执行后续的代码，而是要尝试重新获得object对象的监视器，而这个监视器也正是T1在wait()方法执行前所持有的那个。如果暂时无法获得，则T1还必须等待这个监视器。当监视器顺利获得后，T1才可以在真正意义上继续执行。

![](https://pic.imgdb.cn/item/610b798d5132923bf8cf9823.jpg)

​	注意：Object.wait()方法和Thread.sleep()方法都可以让线程等待若干时间。除wait()方法可以被唤醒外，另外一个主要区别就是wait()方法会释放目标对象的锁，而Thread.sleep()方法不会释放任何资源。

## 挂起（suspend）和继续执行（resume）线程

​	不推荐使用suspend()方法去挂起线程是因为suspend()方法在导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常继续运行（如图2.7所示）。直到对应的线程上进行了resume()方法操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume()方法操作意外地在suspend()方法前就执行了，那么被挂起的线程可能很难有机会被继续执行。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它的线程状态上看，居然还是Runnable，这也会严重影响我们对系统当前状态的判断。

![](https://pic.imgdb.cn/item/610bad095132923bf852e232.jpg)

​	如果需要一个比较可靠的suspend()方法，那么应该怎么办呢？回想一下上一节中提到的wait()方法和notify()方法，这也不是一件难事。下面的代码就给出了一个利用wait()方法和notify()方法，在应用层面实现suspend()方法和resume()方法功能的例子。

![](https://pic.imgdb.cn/item/610bad3b5132923bf85331ee.jpg)

![](https://pic.imgdb.cn/item/610bad495132923bf85348ae.jpg)

### 等待线程结束（join）和谦让（yield）

![](https://pic.imgdb.cn/item/610bb0075132923bf857d85e.jpg)

​	第一个join()方法表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕。第二个方法给出了一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因为“等不及了”，而继续往下执行。

​	join()方法的本质是让调用线程wait()方法在当前线程对象实例上。下面是JDK中join()方法实现的核心代码片段：

![](https://pic.imgdb.cn/item/610bb03d5132923bf8583ce8.jpg)

​	这是一个静态方法，一旦执行，它会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了。当前线程在让出CPU后，还会进行CPU资源的争夺，但是是否能够再次被分配到就不一定了。因此，对Thread.yield()方法的调用就好像是在说：“我已经完成了一些最重要的工作了，我可以休息一下了，可以给其他线程一些工作机会啦！”

​	如果你觉得一个线程不那么重要，或者优先级非常低，而且又害怕它会占用太多的CPU资源，那么可以在适当的时候调用Thread.yield()方法，给予其他重要线程更多的工作机会。

# volatile与Java内存模型（JMM）

![](https://pic.imgdb.cn/item/610bb1025132923bf8595288.jpg)

​	在虚拟机的Client模式下，由于JIT并没有做足够的优化，在主线程修改ready变量的状态后，ReaderThread可以发现这个改动，并退出程序。但是在Server模式下，由于系统优化的结果，ReaderThread线程无法“看到”主线程中的修改，导致ReaderThread永远无法退出（因为代码第7行判断永远不会成立），这显然不是我们想看到的结果。这个问题就是一个典型的可见性问题。

​	和原子性问题一样，我们只要简单地使用关键字volatile来声明ready变量，告诉Java虚拟机，这个变量可能会在不同的线程中修改。这样，就可以顺利解决这个问题了。

# 分门别类的管理：线程组

​	在一个系统中，如果线程数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在同一个线程组里。

​	线程组的使用非常简单，如下：

![](https://pic.imgdb.cn/item/610bb1905132923bf85a2497.jpg)

​	此外，对于编码习惯，我还想再多说几句。强烈建议大家在创建线程和线程组的时候，给它们取一个好听的名字。对于计算机来说，也许名字并不重要，但是在系统出现问题时，你很有可能会导出系统内所有线程，你拿到的如果是一连串的Thread-0、Thread-1、Thread-2，我想你一定会头疼。而你看到的如果是类似HttpHandler、FTPService这样的名字，则会心情倍爽。

# 驻守后台：守护线程（Daemon）

​	守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程。与之相对应的是用户线程，用户线程可以认为是系统的工作线程，它会完成这个程序应该要完成的业务操作。如果用户线程全部结束，则意味着这个程序实际上无事可做了。守护线程要守护的对象已经不存在了，那么整个应用程序就应该结束。因此，当一个Java应用内只有守护线程时，Java虚拟机就会自然退出。

```java
t.setDaemon(true);
```

​	设置守护线程必须在线程start()之前设置，否则你会得到一个类似以下的异常，告诉你守护线程设置失败。

# 先做重要的事：线程优先级

​	在Java中，使用1到10表示线程优先级。一般可以使用内置的三个静态标量表示：

![](https://pic.imgdb.cn/item/610bb2a45132923bf85bb0b6.jpg)

# 线程安全的概念与关键字synchronized

​	关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性。

​	关键字synchronized可以有多种用法，这里做一个简单的整理。

* 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
* 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。
* 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。

