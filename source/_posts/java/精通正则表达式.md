参考《精通正则表达式》

# 1. 正则表达式入门

想象一下这幅图景：你需要检索某台Web服务器上的页面中的重复单词（例如“this this”），进行大规模文本编辑时，这是一项常见的任务。程序必须满足下面的要求：

●能检查多个文件，挑出包含重复单词的行，高亮标记每个重复单词（使用标准 ANSI的转义字符序列（escape sequence）），同时必须显示这行文字来自哪个文件。

●能跨行查找，即使两个单词一个在某行末尾而另一个在下一行的开头，也算重复单词。

●能进行不区分大小写的查找，例如‘The the…’，重复单词之间可以出现任意数量的**空白字符**（空格符、制表符、换行符之类）（译注1）。

●能查找用HTML tag分隔的重复单词。HTML tag用于标记互联网页上的文本，例如，粗体单词是这样表示的：‘…it is ＜B＞very＜/B＞ very important…’。

## 解决实际问题

​	掌握正则表达式，可能带来超乎你之前想象的文本处理能力。每一天，我都依靠正则表达式解决各种大大小小的问题（通常的情况是，问题本身并不复杂，但没有正则表达式就成了大问题）。

## 作为编程语言的正则表达式

Regular Expressions as a Language

### 以文件名做类比

​	The Filename Analogy

​	选择这本书的读者，大概对“正则表达式” 多少有点认识。即便没有，也应该熟悉其中的基本概念。

​	我们都知道，report.txt是一个文件名，但是，如果你用过Unix或者DOS/Windows的话，就会知道“＊.txt”能够用来选择多个文件。在此类文件名（称为“**文件群组**”file globs或者“**通配符**”wildcards）中，有些字符具有特殊的意义。星号表示“任意文本”，问号表示“任意单个字符”。所以，文件群组“＊.txt”以能够匹配字符的「＊」符号开头，以普通文字「.txt」结尾，所以，它的意思是：选择以任意文本开头，以.txt结尾的所有文件。

### 以语言做类比

​	The Language Analogy

​	完整的正则表达式由两种字符构成。特殊字符（special characters，例如文件名例子中的＊）称为“**元字符**”（metacharacters），其他为“**文字**”（literal），或者是普通文本字符（normal text characters）。正则表达式与文件名模式（filename pattern）的区别就在于，正则表达式的元字符提供了更强大的描述能力。文件名模式只为有限的需求提供了有限的元字符，但是正则表达式“语言”为高级应用提供了丰富而且描述力极强的元字符。

## 正则表达式的思维框架

The Regular-Expression Frame of Mind

我们将会看到，完整的正则表达式由小的构建模块单元（building block unit）组成。每个单独的构建模块都很简单，不过因为它们能够以无穷多种方式组合，将它们结合起来实现特殊目标必须依靠经验。所以，本章提供了有关正则表达式的若干概念的总体描述。这一章并没有艰深的内容，而是为本书其余章节的知识打下基础，在深入探索正则表达式之前，把相关事宜阐释清楚。

### 检索文本文件：Egrep

Searching Text Files:Egrep

文本检索是正则表达式最简单的应用之一——许多文本编辑器和文字处理软件都提供了正则表达式检索的功能。最简单的就是egrep。在指定了正则表达式和需要检索的文件之后，egrep会尝试用正则表达式来匹配每个文件的每一行，并显示能够匹配的行。

许多系统——例如DOS、MacOS、Windows、Unix等等——都对应有免费提供的egrep。在本书的网页http：//regex.info上可以找到获得对应读者操作系统的egrep拷贝的链接。

### 行的起始和结束

Start and End of the Line

或许最容易理解的元字符就是**脱字**符号「^」和**美元**符号「$」了，在检查一行文本时，「^」代表一行的开始，「$」代表结束。我们曾经看到，正则表达式「cat」寻找的是一行文本中任意位置的c·a·t，但是「^cat」只寻找行首的 c·a·t——「^」用来把匹配文本（这个表达式的其他部分匹配的字符）“**锚定**”（anchor）在这一行的开头。同样，「cat$」只寻找位于行末的c·a·t，例如以scat结尾的行。

读者最好能养成按照字符来理解正则表达式的习惯。例如，不要这样：

「^cat」匹配以cat开头的行

而应该这样理解：

「^cat」匹配的是以c作为一行的第一个字符，紧接一个a，紧接一个t的文本。

这两种理解的结果并无差异，但按照字符来解读更易于明白新遇到的正则表达式的内部逻辑。egrep会如何解释「^cat$」、「^$」和单个的「^」呢？ϖ 请翻到下页查看答案。

### 字符组

Character Classes

**匹配若干字符之一**

如果我们需要搜索的是单词“grey”，同时又不确定它是否写作“gray”，就可以使用正则表达式结构体（construct）「[…]」。它容许使用者列出在某处期望匹配的字符，通常被称作**字符组**（character class（译注2））。「e」匹配字符e，「a」匹配字符a，而正则表达式「[ea]」能匹配a或者e。所以，「gr[ea]y」的意思是：先找到g，跟着是一个r，然后是一个a或者e，最后是一个y。我很不擅长拼写，所以总是用正则表达式从一大堆英文单词中找到正确的拼写。我经常使用的一个正则表达式是「sep[ea]r[ea]te」，因为我从来都记不住这个单词到底是写作“seperate”，“separate”，“separete”，还是别的什么样子。匹配的结果的就是正确的拼法，而正则表达式就是我的领路人。

![](https://pic.imgdb.cn/item/62e4d34ef54cd3f937aa06dc.jpg)

**排除型字符组**

用`「[^…]」取代「[…]」`，这个字符组就会匹配任何**未**列出的字符。例如，`「[^1-6]」`匹配除了1到 6 **以外**的任何字符。这个字符组中开头的`「^」`表示“排除（negate）”，所以这里列出的不是希望匹配的字符，而是不希望匹配的字符。

### 用点号匹配任意字符

Matching Any Character with Dot

元字符「.」（通常称为点号dot或者小点point）是用来匹配任意字符的字符组的简便写法。如果我们需要在表达式中使用一个“匹配任何字符”的占位符（placeholder），用点号就很方便。例如，如果我们需要搜索03/19/76、03-19-76或者03.19.76，不怕麻烦的话用一个明确容许‘/’、‘-’、‘.’的字符组来构建正则表达式，例如「03[-./]19[-./]76」。也可以简单地尝试「03.19.76」。

### 多选结构

Alternation

**匹配任意子表达式**

「|」是一个非常简捷的元字符，它的意思是“**或**”（or）。依靠它，我们能够把不同的子表达式组合成一个总的表达式，而这个总的表达式又能够匹配任意的子表达式。假如「Bob」和「Robert」是两个表达式，但「Bob|Robert」就是能够同时匹配其中任意一个的正则表达式。在这样的组合中，子表达式称为“**多选分支**（alternative）”。

### 忽略大小写

Ignoring Differences in Capitalization

E-mail header的例子很适合用来说明**不区分大小写**（case-insensitive）的匹配的概念。E-mail header中的字段类型（field type）通常是以大写字母开头的，例如“Subject”和“From”，但是E-mail标准并没有对大小写进行严格的规定，所以“DATE”或者“from”也是合法的字段类型。但是，之前使用的正则表达式无法处理这种情况。

一种办法是用「[Ff][Rr][Oo][Mm]」取代「From」，这样就能匹配任何形式的“from”，但缺点之一就是很不方便。幸好，我们有一种办法告诉egrep在比较时忽略大小写，也就是进行不区分大小写的匹配，这样就能忽略大小写字母的差异。

该功能并不是正则表达式语言的一部分，却是许多工具软件提供的有用的相关特性。egrep的命令行参数“-i”表示进行忽略大小写的匹配。把-i写在正则表达式之前：

### 单词分界符

Word Boundaries

使用正则表达式时经常会遇到的一个问题，期望匹配的“单词”包含在另一个单词之中。在cat、gray和Smith的例子中，我曾提到过这个问题。不过，某些版本的egrep对单词识别提供了有限的支持：也就是单词分界符（单词开头和结束的位置）的匹配。

如果你的egrep支持“**元字符序列**（metasequences）” 「\＜」和「\＞」，就可以使用它们来匹配单词分界的位置。可以把它们想象为单词版本的「^」和「$」，分别用来匹配单词的开头和结束位置。就像作为行锚点的脱字符和美元符一样，它们锚定了正则表达式的其他部分，但在匹配过程中并不对应到任何字符。表达式「\＜cat\＞」的意思是“匹配单词的开头位置，然后是c·a·t这3个字母，然后是单词的结束位置”。更直接点说就是“匹配cat这个单词”。如果读者愿意，也可以用「\＜cat」和「cat\＞」来匹配以cat开头和结束的单词。

![](https://pic.imgdb.cn/item/62e4d516f54cd3f937b55f57.jpg)

### 可选项元素

Optional Items

现在来看color和colour的匹配。它们的区别在于，后面的单词比前面的多一个u，我们可以用「colou？r」来解决这个问题。元字符「？」（也就是**问号**）代表**可选项**。把它加在一个字符的后面，就表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件。

「u？」这个元字符与我们之前看到的元字符都不相同，它只作用于之前紧邻的元素。因此，「colou？r」的意思是：「c」，然后是「o」，然后是「l」，然后是「o」，然后是「u？」，最后是「r」。

### 其他量词：重复出现

Other Quantifiers:Repetition

「+」（加号）和「＊」（星号）的作用与问号类似。元字符「+」表示“之前紧邻的元素出现一次或多次”，而「＊」表示“之前紧邻的元素出现任意多次，或者不出现”。换种说法就是，「…＊」表示“匹配尽可能多的次数，如果实在无法匹配，也不要紧”。「…+」的意思与之类似，也是匹配尽可能多的次数，但如果连一次匹配都无法完成，就报告失败。问号、加号和星号这 3个元字符，统称为**量词**（quantifiers），因为它们限定了所作用元素的匹配次数。

### 括号及反向引用

Parentheses and Backreferences

到目前为止，我们已经见过括号的两种用途：限制多选项的范围；将若干字符组合为一个单元，受问号或星号之类量词的作用。现在我要介绍括号的另一种用途，虽然它在egrep中并不常见（不过流行的GNU版本确实支持这一功能），但在其他工具软件中很常见。

在许多流派（flavor）的正则表达式中，括号能够“记住”它们包含的子表达式匹配的文本。在解决本章开始提到的单词重复问题时就会用到这个功能。如果我们确切知道重复单词的第一个单词（比方说这个单词就是“the”），就能够明确无误地找到它，例如「the·the」。这样或许还是会匹配到![img](http://localhost:8000/8d0b511a-54aa-4440-866e-0232e9675959/images/00018.jpeg)的情况，但如果我们的egrep支持在第15页提到的单词分界符「\＜the·the\＞」，这个问题就很容易解决。我们可以添加「·+」把这个表达式变得更灵活。

然而，穷举所有可能出现的重复单词显然是不可能完成的任务。如果我们先匹配任意一个单词，接下来检查“后面的单词是否与它一样”，就好办多了。如果你的egrep支持“**反向引用**（backreference）”，就可以这么做。反向引用是正则表达式的特性之一，它容许我们匹配与表达式先前部分匹配的同样的文本。

我们先把「\＜the·+the\＞」中的第一个「the」替换为能够匹配任意单词的正则表达式「[A-Za-z]+」；然后在两端加上括号（原因见下段）；最后把后一个‘the’替换为特殊的元字符序列「\1」，就得到了「\＜（[A-Za-z]+）·+\1\＞」。

在支持反向引用的工具软件中，括号能够“记忆”其中的子表达式匹配的文本，不论这些文本是什么，元字符序列「\1」都能记住它们。

当然，在一个表达式中我们可以使用多个括号。再用「\1」、「\2」、「\3」等来表示第一、第二、第三组括号匹配的文本。括号是按照开括号‘（’从左至右的出现顺序进行的，所以「（[a-z]）（[0-9]）\1\2」中的「\1」代表「[a-z]」匹配的内容，而「\2」代表「[0-9]」匹配的内容。

在‘the·the’的例子中，「[A-Za-z]+」匹配第一个‘the’。因为这个子表达式在括号中，所以「\1」代表的文本就是‘the’。如果「·+」能够匹配，后面的「\1」要匹配的文本就是‘the’。如果「\1」也能成功匹配，最后的「\＞」对应单词的结尾（如果文本是‘the·theft’，这一条就不满足）。如果整个表达式能匹配成功，我们就得到一个重复单词。有的重复单词并不是错误，例如‘that that’（译注3），这并不是正则表达式的错误，真正的判断还得靠人。我决定使用上面这个例子的时候，已经用这个表达式检查过本书之前的内容了（我使用的是支持「\＜…\＞」和反向引用的egrep）。我还使用了第15页提到的忽略大小写的参数-i来拓宽它的适用范围（注8），所以‘The·the’这样的单词重复也能提取出来。

我使用的命令如下：

%egrep-i'\＜([a-z]+)+\1\＞'files…

结果令我惊奇，居然找到了14组重复单词。我把它们全都改正了，而且把这个表达式添加到我用来检查本书拼写错误的工具中，保证从此以后全书中不会出现这样的错误。

### 神奇的转义

The Great Escape

有个重要的问题我尚未提及，即：如果需要匹配的某个字符本身就是元字符，正则表达式会如何处理呢？例如，如果我想要检索互联网的主机名ega.att.com，使用「ega.att.com」可能得到![img](http://localhost:8000/8d0b511a-54aa-4440-866e-0232e9675959/images/00019.jpeg)的结果。还记得吗？「.」本身就是元字符，它可以匹配任何字符，包括空格。

真正匹配文本中点号的元序列应该是反斜线（backslash）加上点号的组合：「ega\.att\.com」。「\.」称为“**转义的点号**”或者“**转义的句号**”，这样的办法适用于所有的元字符，不过在字符组内部无效（注9）。

这样使用的反斜线称为“转义符（escape）”——它作用的元字符会失去特殊含义，成了普通字符。如果你愿意，也可以把转义符和它之后的元字符看作特殊的元字符序列，这个元字符序列匹配的是元字符对应的普通字符。这两种看法是等价的。

## 基础知识拓展

Expanding the Foundation

我希望，前面的例子和解释已经帮助读者牢固地打下了正则表达式的基础，也请读者明白，这些例子都很浅显，我们需要掌握的还有很多。

### 语言的差异

Linguistic Diversification

我已经介绍过大多数版本的egrep支持的正则表达式的特性，这样的特性还有很多，其中一些并不是所有的版本都支持，这个问题留到后面的章节讲解。

### 正则表达式的目标

The Goal of a Regular Expression

从最宏观的角度看，一个正则表达式要么能够匹配给定文本（对egrep来说，就是一行文本）中的某些字符，要么不能匹配。在编写正则表达式的时候，我们必须进行权衡：匹配符合要求的文本，同时忽略不符合要求的文本。

尽管egrep不关心匹配文本在行中的位置，但对正则表达式的其他应用来说，这个问题却很重要。如果文本是这样：

### 更多的例子

A Few More Examples

在任何语言中，经验**都是非常重要的**，所以我会给出更多用正则表达式匹配常用文本结构的例子。

编写正则表达式时，按照预期获得成功的匹配要花去一半的工夫，另一半的工夫用来考虑如何忽略那些不符合要求的文本。在实践中，这两方面都非常重要，但是目前我们只关注“获得成功匹配”的方面。即使我没有对这些例子进行最全面彻底的解释，它们仍然能够提供有用的启示。

**变量名**

许多程序设计语言都有标识符（identifier，例如变量名）的概念，标识符只包含字母、数字以及下画线，但不能以数字开头。我们可以用「[a-zA-Z_][a-zA-Z_0-9]＊」来匹配标识符。第一个字符组匹配可能出现的第一个字符，第二个（包括对应的「＊」）匹配余下的字符。如果标识符的长度有限制，例如最长只能是32个字符，又能使用第20页介绍的区间量词「{min，max}」，我们可以用「{0，31}」来替代最后的「＊」。

**引号内的字符串**

匹配引号内的字符串最简单的办法是使用这个表达式：「＂[^＂]＊＂」。

两端的引号用来匹配字符串开头和结尾的引号。在这两个引号之间的文本可以包括双引号之外的任何字符。所以我们用「[^＂]」来匹配除双引号之外的任何字符，用「＊」来表示两个引号之间可以存在任意数目的非双引号字符。

关于引号字符串，更有用（也更复杂）的定义是，两端的双引号之间可以出现由反斜线转义的双引号，例如＂nail·the·2\＂x4\＂·plank＂。在后面的章节讲解匹配实际进行的细节时，我们会多次遇到这个例子。

**美元金额（可能包含小数）**

「\$[0-9]+（\.[0-9][0-9]）？」是一种匹配美元金额的办法。

从整体上看，这个表达式很简单，分为三部分：「\$」、「…+」和「（…）？」，可以大致理解为：一个美元符号，然后是一组字符，最后可能还有另一组字符。这里的“字符”指的是数字（一组数字构成一个数值），“另一组字符”是由一个小数点和两位数字构成的。

从几个方面来看，这个表达式还很简陋。比如，它只能接受$1000，而无法接受$1，000。它确实能接受可能出现的小数部分，但对于egrep来说意义不大。因为egrep从不关心匹配文字的内容，而只关心是否存在匹配。处理可能出现的小数部分对整个表达式能否匹配并没有影响。

但是，如果我们需要找到只包含价格而不含其他字符的行，倒是可以在这个表达式两端加上「^…$」。这样一来，可选的小数部分就变得很重要了，因为在金额数值和换行符之间是否存在小数部分，决定了整个表达式的匹配结果是否存在差异。

另外，这个正则表达式还无法匹配‘$.49’。你可能认为把加号换成星号能够解决问题，不过这条路走不通。在这我先卖个关子，答案留待第5章（☞194）揭晓。

HTTP/HTML URL

Web URL的形式可能有很多种，所以构造一个能够匹配所有形式的URL的正则表达式颇有难度。不过，稍微降低一点要求的话，我们能够用一个相当简单的正则表达式来匹配大多数常见的 URL。进行这种检索的原因之一是，我只能大概记得在收到的某封邮件中有一个URL地址，不过一见到它我就能认出来。

常见的HTTP/HTML URL是下面这样的：

http://hostname/path.html

当然，.htm的结尾也很常见。

hostname（主机名，例如www.yahoo.com）的规则比较复杂，但是我们知道，跟在‘http：//’之后的就有可能是主机名，所以这个正则表达式就很简单，「[-a-z0-9_.]+」。path部分的变化更多，所以我们需要使用「[-a-z0-9_：@&？=+，.！/～＊%$]＊」。请注意，连字符必须放在字符组的开头，保证它是一个普通字符，而不是用来表示范围（☞9）。

综合起来，我们第一次尝试的正则表达式就是：

%egrep-i '\＜http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~＊%$]＊\.html?\＞' files

因为我们降低了对匹配的要求，所以‘http：//..../foo.html’也能匹配，虽然它显然不是一个合法的 URL。我们需要关心这一点吗？这取决于具体的情况。如果我只是需要扫描自己的E-mail，得到一些错误结果并不算是问题。而且，我没准会用更简单的表达式：

%egrep-i '\＜http://[^]＊\.html?\＞' files…

在深入了解如何调校正则表达式之后，读者会明白，要想在复杂性和完整性之间求得平衡，一个重要的因素是了解待搜索的文本。下一章，我们会更详细地考察这个例子。

HTML tag

对egrep这样的工具来说，简单地匹配包含HTML tag的行并不常见，也没什么用。但是，探索如何准确匹配一个HTML tag却是相当有启发的，在下一章深入接触更高级的工具时，这一点尤其明显。

简单的例子包括‘＜TITLE＞’和‘＜HR＞’，我们可能会想到「＜.＊＞」。这个简单的表达式往往是最直接的想法，但它显然是不对的。「＜.＊＞」的意思是，“先匹配一个‘＜’，然后是任意多个任意字符，然后是‘＞’”。所以，它无疑能够匹配不止一个tag的内容。

也许结果有点出乎你的意料，但是我们目前还只在第 1 章，对正则表达式的理解也不够深入。我之所以举这个例子，是想说明正则表达式并不复杂，但是如果你不真正弄懂它们，可能会被搞得晕头转向。在下面的几章中，我们会学习理解和解决这个问题需要的所有细节。

### 正则表达式术语汇总

Regular Expression Nomenclature

**正则（regex）**

你或许已经猜到了，“正则表达式”（regular expression）这个全名念起来有点麻烦，写出来就更麻烦。所以，我一般会采用“正则”（regex）的说法。这个单词念起来很流畅（有点像联邦快递的FedEx，与regular一样，g发重音，而不同于Regina），而且说“如果你写一个正则”，“巧妙的正则”（budding regexers），甚至是“正则化”（regexification）（注10）（译注4）。

**匹配（matching）**

一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。严格地说，正则表达式「a」不能**匹配** cat，但是能匹配 cat中的 a。几乎没人会混淆这两个概念，但澄清一下还是有必要的。

**元字符（metacharacter）**

一个字符是否元字符（或者是“元字符序列”（metasequence），这两个概念是相等的），取决于应用的具体情况。例如，只有在字符组外部并且是在未转义的情况下，「＊」才是一个元字符。“转义”（escaped）的意思是，通常情况下在这个字符之前有一个反斜线。「\＊」是对「＊」的转义，而「\\＊」则不是（第一个反斜线用来转义第二个反斜线），虽然在两个例子中，星号之前都有一个反斜线。

正则表达式的流派（flavor）不同，关于字符转义的规定也不相同。第3章对此进行了详细讨论。

**流派（flavor）**

我已经说过，不同的工具使用不同的正则表达式完成不同的任务，每样工具支持的元字符和其他特性各有不同。我们再举单词分界符的例子。某些版本的 egrep 支持我们曾见过的\＜…\＞表示法。而另一些版本不支持单独的起始和结束边界，只提供了统一的「\b」元字符（这个元字符我们还没见过，下一章才会用到）。还有些工具同时支持这两种表示法，另有许多工具哪种也不支持。

**子表达式（**subexpression**）**

“子表达式”指的是整个正则表达式中的一部分，通常是括号内的表达式，或者是由「|」分隔的多选分支。例如，在「^（Subject|Date）：·」中，「Subject|Date」通常被视为一个子表达式。其中的「Subject」和「Date」也算得上子表达式。而且，严格说起来，「S」、「u」、「b」、「j」这些字符，都算子表达式。

**字符（**character**）**

“字符”在计算机领域是一个有特殊意义的单词。一个字节所代表的单词取决于计算机如何解释。单个字节的值不会变化，但这个**值**所代表的**字符**却是由解释所用的编码来决定的。例如，值为64和53的字节，在ASCII编码中分别代表了字符“@”和“5”，但在EBCDIC编码中，则是完全不同的字符（一个是空格，一个是控制字符）。

### 改进现状

Improving on the Status Quo

总的来说，正则表达式并不难。但是，如果你与使用过支持正则表达式的程序或语言的人交流过就会发现，某些人确实“会用”正则表达式，但如果需要解决复杂的问题，或是换用他们不熟悉的工具，就会出问题。

传统的正则表达式文档大都只包含一两个元字符的简略介绍，然后就给出关于其他元字符的表格。给出的例子通常也是无意义的「a＊（（ab）＊|b＊）」，文本则是‘a·xxx·ce·xxxxxx· ci·xxx·d’。这些文档大都忽略了细微但重要的知识点，总是声称自己与其他出名的工具属于同一流派，而忘记提及必然存在的差异。它们缺乏实用价值。

●**正则表达式的使用** 许多程序使用的正则表达式比egrep要复杂。在我们探讨如何构造真正有用的正则表达式的细节之前，需要知道正则表达式的使用方法。下一章关注这一问题。

●**正则表达式的特性（**feature**）** 面对问题，选择合适的工具是成功的一半，所以我会在全书中使用多种工具。不同的程序，甚至是同一个程序的不同版本，支持的特性和元字符都不一样。在了解使用细节之前，我们必须搞清楚这个问题。这是第3章的主题。

●**正则表达式的工作原理** 在我们接触有用（但通常也很复杂）的例子之前，我们必须“揭开盖子”来了解正则表达式的工作原理。我们将会看到，对某些元字符进行尝试匹配的次序是一个重要的问题。实际上，正则表达式引擎（regular expression engine）不同，工作原理也不同，所以对于同样的正则表达式，不同的程序会得到不同的结果。我们将在第4、5、6章中探讨这个复杂的问题。

![](https://pic.imgdb.cn/item/62e4d8a2f54cd3f937cbf4b6.jpg)

## 一家之言

Personal Glimpses

本章开始的单词重复的例子可能有些让人迷惑，不过正则表达式的功能的确很强大，我们只需要egrep这样简单的工具，用第1章的知识，就能够基本解决这个问题。我倒是希望在本章多讲些复杂点的例子，但是因为我希望用第 1 章为后面的章节打下坚实的基础，我担心，如果这一章满是提醒、注意、规则之类，那些从未接触过正则表达式的人在读完之后，或许会感到困惑——“需要这么麻烦吗？”