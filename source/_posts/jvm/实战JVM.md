---
title: 实战JVM
date: 2020-8-15 21:37:31
tags: [JVM]
---

# 第1章 初探Java虚拟机

略

# 第2章 认识Java虚拟机的基本结构

本章 涉及 的 主要 知识 点 有：

- 认识 Java 虚拟 机 中的 堆。
- 了解 有关 栈 的 概念 和 使用。
- 了解 存放 类型 描述 的 永久 区 和 元 数据区。

## 2.1 谋全局者才能成大器：看穿Java虚拟机的架构

[![img](https://pic.imgdb.cn/item/5f635904160a154a67efeade.jpg)](https://pic.imgdb.cn/item/5f635904160a154a67efeade.jpg)



 类加载子系统负责从文件系统或网络中加载Class信息，加载的类信息存放于一块称为方法去的内存空间中。除了类信息，方法去还会存放运行时常量池信息，包括字符串字面量和数字常量。

 Java堆在虚拟机启动的时候建立，是Java程序最主要的工作区域。几乎所有的Java实例都存放在Java堆中。堆空间是所有线程共享的。

 Java的NIO库允许Java程序使用直接内存。是存在与Java堆外、直接向系统申请的内存区域。通常，访问直接内存的速度会优先于Java堆。受限于系统的最大内存。

 垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、Java堆和直接内存进行回收。其中，Java堆是垃圾收集器的工作重点。

 每一个Java虚拟机线程都有一个私有的Java栈。一个线程的Java栈在线程启动的时候被创建。Java栈中保存着帧信息，Java栈中保存着局部变量、方法参数，同时和Java方法的调用、返回密切相关。

 本地方法栈和Java栈特别类似，最大不同在于Java栈用于Java方法的调用，本地方法栈则用于本地方法的调用。

 PC寄存器也是每个线程私有的空间，Java虚拟机会为每一个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个方法被称为当前方法。如果当前方法不是本地方法，就会指向被执行的命令，如果是，值就是undefined。

## 2.2 小参数能解决大问题：学会设置Java虚拟机参数

```
java [-options] class [args...]
```

-options表示Java虚拟机的启动参数， args表示传递给主函数main()的参数。

如果需要设定特定的Java虚拟机参数，在options处指定即可。

## 2.3 对象去哪儿：辨清Java堆

 几乎所有对象都是存放在堆中，通过垃圾回收机制，垃圾对象会被自动清理。

 垃圾回收机制不同，可能有不同的结构，最常见的如下:

[![img](https://pic.imgdb.cn/item/5f635f97160a154a67f1a941.jpg)](https://pic.imgdb.cn/item/5f635f97160a154a67f1a941.jpg)

 绝大多数情况下，对手首先在eden区分配，在一次新生代回收后，如果对象还存活，则会进入s0或s1。每次经过一次新生代回收，如果对象存活，年龄就+1。到达一定条件后，进入老年代。

```
package cn.sorie;

public class SimpleHeap {
    private int id;
    public SimpleHeap(int id) {
        this.id = id;
    }
    public void show() {
        System.out.println("My ID is" + id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
        s1.show();
        s2.show();
    }
}
```

 SimpleHeap实例本身在堆中分配，描述SimpleHeap类的信息存放在方法区，main()函数中的s1和s2局部变量存放在Java栈中，并且指向堆中的两个实例。

[![img](https://pic.imgdb.cn/item/5f6362d4160a154a67f2a435.jpg)](https://pic.imgdb.cn/item/5f6362d4160a154a67f2a435.jpg)

## 2.4 函数如何调用：出入Java栈

 Java栈是一块线程私有的内存空间。线程执行的基本行为是函数调用，每次函数调用都是通过Java栈传递的。

 是一块先进后入的数据结构，只支持出栈和入栈两种操作。Java栈中保存的主要内容为栈帧。当前正在执行的函数所对应的帧就是当前的帧(位于栈顶)，它保存着当前函数的局部变量、中间运算结果等数据。

 函数返回时，栈帧从Java栈中被弹出。Java有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。

 一个栈帧中，至少要包含局部变量表、操作数栈和帧数据区几部分。

[![img](https://pic.imgdb.cn/item/5f636489160a154a67f323c5.jpg)](https://pic.imgdb.cn/item/5f636489160a154a67f323c5.jpg)

 如果栈空间不足，那么函数调用自然无法继续进行。当前请求的栈深度大于最大可用栈深度，就会抛出StackOverflowError栈溢出错误。

 通过参数-Xss128K，可以调整栈大小。

### 2.4.1 局部变量表

 是栈帧的重要组成部分一直，用于保存函数的参数及局部变量、局部变量表中的变量只在函数调用中有效，调用结束，栈帧就销毁，局部变量表也会销毁。

 如果函数的参数和局部变量较多，会使局部变量表膨胀，最终导致函数嵌套次数减少。

[![img](https://pic.imgdb.cn/item/5f6365e5160a154a67f37a5b.jpg)](https://pic.imgdb.cn/item/5f6365e5160a154a67f37a5b.jpg)

局部变量表的变量也是重要的垃圾回收根节点，被局部变量表中直接或间接引用的对应都不会被回收。

### 2.4.2 操作数栈

 栈帧中重要内容之一，用于保存计算中间结果，通识作为计算过程中变量临时的计算存储空间。

[![img](https://pic.imgdb.cn/item/5f636661160a154a67f39849.jpg)](https://pic.imgdb.cn/item/5f636661160a154a67f39849.jpg)

### 2.4.3 帧数据区

 除了局部变量表和操作数栈，Java栈帧还需要一些数据来支持常量池解析、正常方法返回和异常处理操作。大部分Java字节码指令需要进行常量池访问，在帧数据区中国保存着访问常量池的指针，方便访问常量池。

 此外，函数如果出现异常，虚拟机必须回复调用者函数的栈帧，并且让调用者函数继续执行。对于异常处理，虚拟机必须有一个异常处理表，方便在异常时找到处理异常的代码。

[![img](https://pic.imgdb.cn/item/5f6366f0160a154a67f3bc4e.jpg)](https://pic.imgdb.cn/item/5f6366f0160a154a67f3bc4e.jpg)

 第一行表示4到16字节可能抛出任意异常，如果遇到则跳转到字节码偏移19处执行。

### 2.4.4 栈上分配

 是Java虚拟机提供的一项优化技术，基本思想是，对于那些线程私有(不会被其他线程访问的对象)，可以将它们打散分配在栈上，而不是在堆上。好处是可以自行销毁，不需要垃圾回收器的接入。

 一个技术基础是进行逃逸分析。目的是判断对象的作用于是否有可能逃出函数体。

 对于没有逃逸的对象，虚拟机可能将其分配在栈上。

 在Server模式(-server)下，才可以启用逃逸分析。参数-XX:+DoEscapeAnalysis启用逃逸分析。

[![img](https://pic.imgdb.cn/item/5f6367fa160a154a67f4095b.jpg)](https://pic.imgdb.cn/item/5f6367fa160a154a67f4095b.jpg)

 关闭逃逸分析或标量替换中的任何一个，就会看到大量日志。栈上分配依赖逃逸分析和标量替换的实现。

 对于大量零散的小对象，栈上分配提供了一种很好的对象分配优化策略，栈上分配速度很快，并且可以有效避免垃圾回收带来的负面影响。大对象无法也不合适在栈上分配。

## 2.5 类去哪儿了：识别方法区

 所有线程共享。保存类信息，比如字段、方法、常量池。大小决定系统可以保存多少个类，如果定义了太多类，导致方法区溢出，会抛出内存溢出错误。

 JDK1.6,1.7中，方法去可以理解为永久区。永久区可以使用参数-XX:PermSize和-XX:MaxPermSize指定。默认-XX:MaxPermSize为64MB。如果系统使用了一些动态大力，这是需要设置一个合适的永久区大小，确保不会发生内存溢出。

 JDK1.8之后，永久区已经被彻底移除，取而代之的是元数据区，通过参数-XX:MaxMetaspaceSize指定，默认情况下会耗尽所有系统内存。

[![img](https://pic.imgdb.cn/item/5f63695e160a154a67f46726.jpg)](https://pic.imgdb.cn/item/5f63695e160a154a67f46726.jpg)

 元数据区发生溢出会抛出异常。

[![img](https://pic.imgdb.cn/item/5f636951160a154a67f4639b.jpg)](https://pic.imgdb.cn/item/5f636951160a154a67f4639b.jpg)

# 第3章 常用Java虚拟机参数

本章知识点：

- 跟踪Java虚拟机的垃圾回收和类加载等信息。
- 配置Java虚拟机的堆空间
- 配置永久区和Java栈
- 学习虚拟机的服务器和客户端模式

## 3.1 一切运行都有迹可循：掌握跟踪调试参数

 如果可以跟踪系统的运行状态，对故障排查会有一定帮助。

### 3.1.1 跟踪垃圾回收——读懂虚拟机日志

 Java一大特色就是支持自动垃圾回收(GC)。但是垃圾回收频繁，或者占用了太长CPU时间，就要引起重视。

 最简单的一个GC参数就是-XX:+PrintGC(在JDK9, JDK10中建议使用-Xlog:gc), 加了参数后，只要遇到GC，就会打印日志。如下：

[![img](https://pic.imgdb.cn/item/5f66e6e7160a154a67dc971d.jpg)](https://pic.imgdb.cn/item/5f66e6e7160a154a67dc971d.jpg)

 日志显示，一共进行了4次GC，每次GC占一行。GC前，堆空间使用量4MB，在GC后，堆空间使用量为377K, 当前可用给的堆空间总和约为16MB(15935KB)。最后显示的是本次GC所花的时间。

 JDK9, JDK10默认使用G1作为垃圾回收器。使用参数-Xlog:gc来打印GC日志。

[![img](https://pic.imgdb.cn/item/5f66e7b0160a154a67dcc91a.jpg)](https://pic.imgdb.cn/item/5f66e7b0160a154a67dcc91a.jpg)

 一共进行了1次GC，GC前，堆空间使用量16MB，GC后，堆空间使用量7MB。当前可用堆空间综合34MB。最后显示GC耗时，23.511。

 如果需要更详尽的信息，可以使用-XX:+PrintGCDetails。JDK8(JDK9和JDK10建议使用-Xlog:gc*)的输出如下：

[![img](https://pic.imgdb.cn/item/5f66e837160a154a67dce821.jpg)](https://pic.imgdb.cn/item/5f66e837160a154a67dce821.jpg)

 经历了3次GC，第一次仅为新生代GC，回收效果是新生代回收前从8MB左右降到了1MB。整个堆从22MB左右降低到17MB。

 第2次(加粗部门)为Full GC，它同时回收了新生代、老年代和永久区。新生代在这次GC中没有释放空间(严格来说是GC日志的一个小bug事实上，这次Full GC后，新生代被清空，由于GC日志输出的时机，各个版本JDK日志多多少少有些不太精确的地方), 老年代从16MB降低到13MB。整个堆大小从26MB左右降低到13MB左右(大小完全与老年代时机大小相等，因此可以推断，新生代实际上已经被清空)。永久区没有发生变化。日志最后显示了GC所花时间，user表示用户态耗时，sys表示系统CPU耗时，real表示GC实际经历的时间。

 该参数还会使虚拟机在退出前打印对的详细信息。详细信息描述了各个区间的使用情况。如上输出所示，当前新生代(new generation)总大小为9792KB, 已使用4586KB。紧跟其后的3个16进制数字表示新生代的下界、当前上界和上界。

[![img](https://pic.imgdb.cn/item/5f66eb10160a154a67dd99aa.jpg)](https://pic.imgdb.cn/item/5f66eb10160a154a67dd99aa.jpg)

 使用上界减去下界就能得到当前堆空间的最大值，使用当前上界减去下界，就是当前虚拟机已经为程序分配的空间。如果当前上界等于下界，说明当前的堆空间已经没有扩大的可能性。

 可能性。 在 本例 中（ 0x00000000f98a0000- 0x00000000f8e00000）/ 1024= 10880KB。 这块 空间 正好 等于 eden+ from+ to 的 总和。 而可 用的 新生代 9792KB 为 eden+ from（ to） 的 总和， 对于 两者 出现 差异 的 原因， 可以 参考 本书 第 4 章。

 JDK9、JDK10使用参数-Xlog:gc*来打印更详细的GC日志，如下所示：

[![img](https://pic.imgdb.cn/item/5f66eda5160a154a67de3862.jpg)](https://pic.imgdb.cn/item/5f66eda5160a154a67de3862.jpg)

 从输出中可以看到，堆最大可用大小为32MB, 系统经历了1次GC，为新生代GC，回收的效果是整个堆从14MB左右降到了1MB。JDK9、JDK10中，除了新生代、老年代，还新增了一个巨型区域，即上述输出中的Humongous regions。

 另外，日志有详细的时间信息，第一列显Java程序的运行时间，Pause Young(G1 Evacuation Pause) 14->1M(32M) 7.028ms表示新生代垃圾回收花了7.028ms。

 Pre Evacuate Collection Set, Evacuate Collection Set, Post Evacuate Collection Set, Other 代表G1垃圾回收标记-清除算法不同阶段所花费的时间。

 如果需要更全面的堆信息，还可以使用-XX:+PrintHeapAtGC(考虑到兼容性，JDK9开始已经删除此参数，查看堆信息可以使用VisualVM)。它会在每次GC前、后分别打印对的信息。

 如果需要GC发生时间，还可以使用-XX:PrintGCTimeStamps(JDK9, JDK10中使用-Xlog:gc*已经默认打印出时间)。

[![img](https://pic.imgdb.cn/item/5f66f076160a154a67df1f02.jpg)](https://pic.imgdb.cn/item/5f66f076160a154a67df1f02.jpg)

 由于GC会引起应用程序停顿，因此还需要特别关注应用程序的执行时间和停顿时间。使用参数-XX:+PrintGCApplicationConcurrentTime可以打印应用执行时间，使用参数-XX:+PrintGCApplicationStoppedTime可以打印应用程序由于GC而产生的停顿时间，如下所示：如果想跟踪系统内的软引用、弱引用、虚引用和Finallize队列，可以打开-XX:+PrintReferenceGC(考虑到兼容性，JDK9已经删除此参数)开关。

 默认情况下，GC日志会在控制台输出，不便于后续分析和定位问题，所以虚拟机允许将GC日志以文件形式输出，可以使用-Xloggc指定。比如使用参数-Xloggc:log/gc.log(JDK9,10建议使用-Xlog:gc:log/gc.log)启动虚拟机。

### 3.1.2 类加载/卸载的追踪

 一般情况下，系统加载的类存在于文件系统中，以jar的形式打包或以class文件的形式存在，可以直接通过文件系统查看。

 但是伴随动态代理，AOP等技术的普遍使用，系统也极有可能在运行时动态生成某些类，这些类相对比较隐蔽，无法通过文件系统找到。

 使用参数-verbos:class最终类的加载/卸载。

 也可以单独使用参数-XX:+TraceClassLoding(在JDK9, 10中建议使用-Xlog:class+load=info, 就跟JDK8中的参数-XX:+TraceClassLoding效果一样)跟踪类加载。

 使用参数-XX:+TraceClassUnloading(在JDK9, JDK10中建议使用-Xlog:class+unload=info)跟踪类的加载。

 下面代码使用ASM动态生成名为Example类，将其反复加载到系统中。

[![img](https://pic.imgdb.cn/item/5f66f3b0160a154a67dff7df.jpg)](https://pic.imgdb.cn/item/5f66f3b0160a154a67dff7df.jpg)

[![img](https://pic.imgdb.cn/item/5f66f3f6160a154a67e00800.jpg)](https://pic.imgdb.cn/item/5f66f3f6160a154a67e00800.jpg)

 日志中可以看到，先加载了Object类，作为所有类的父类。后半部分显示，对Example类先后进行了10次加载和9次卸载

 注意：动态类的加载非常隐蔽，由代码逻辑控制，不出现文件系统中。

 Java虚拟机还允许研发人员在运行时打印、查看系统中类的分布情况，只要在系统启动时加上-XX:+PrintClassHistogram参数。然后在Java控制台中按下Ctrl+Break组合键，控制台就会显示当前类信息柱状图。

[![img](https://pic.imgdb.cn/item/5f66f48f160a154a67e02703.jpg)](https://pic.imgdb.cn/item/5f66f48f160a154a67e02703.jpg)

### 3.1.3 查看系统参数

 由于系统支持众多可配置参数，不同参数对系统的执行效果有较大的影响，有必要确定当前系统实际运行参数。

 参数-XX:+PrintVMOptions可以在程序运行时，打印虚拟机接收到的命令行显示参数。

 参数-XX:+PrintCommandLineFlags可以打印传递给虚拟机的显示和隐式参数，隐式参数未必是通过命令行直接给出的，它可能是在虚拟机器启动时自动设置的。

 另外一个有用的参数是-XX:+PrintFlagsFinal，它会打印所有的系统参数的值。开启这个参数后，可能会产生500多行参数。

## 3.2 让性能飞起来：学习堆的配置参数

### 3.2.1 最大堆和初始堆的设置

 Java进程启动时，虚拟机就会分配一块初始堆大小，可以使用参数-Xms指定这块空间的大小。如果初始堆空间耗尽，将会对堆空间进行扩展，其扩展的上限为最大对抗空间。最大堆空间可以使用参数-Xmx指定。

 最大内存由-XX:MaxHeapSize=20971520指定。而打印的最大可用内存比设定值略少。因为分配给堆空间和实际的内存空间并非一个概念。由于垃圾回收需要，会对堆空间进行分区管理，一些算法会使用空间换时间的策略，因此会存在可用内存的损失。

 最终结果就是实际可用内存会浪费大小等于from/to的空间。因此最大可用内存为-Xmx减去from的值。这样算下来可能还会有偏差，是因为虚拟机内存进一步对堆的from/to做了对齐操作。对于串行GC的情况，虚拟机使用一下方法估算from/to的大小。

[![img](https://pic.imgdb.cn/item/5f66f79a160a154a67e0c6d6.jpg)](https://pic.imgdb.cn/item/5f66f79a160a154a67e0c6d6.jpg)

 提示：在实际工作中，也可以将初始堆和最大堆设置为相等，这样的好处是，可以减少程序运行时，进行垃圾回收的次数，从而提高程序的性能。

### 3.2.2 新生代的配置

 参数-Xmn可以用于设置新生代的大小。设置一个新生代会减少老年代的大小，这个参数对系统性能有很大影响。新生代大小一般为整个堆空间的1/3到1/4.

 参数-XX:SurvivorRatio用来设置新生代中eden区和from/to区的比例。

[![img](https://pic.imgdb.cn/item/5f66f8cd160a154a67e10eed.jpg)](https://pic.imgdb.cn/item/5f66f8cd160a154a67e10eed.jpg)

(1)使用- Xmx20m- Xms20m- Xmn1m- XX: SurvivorRatio= 2- XX:+ PrintGCDetails 运行 上述 Java 程序。

[![img](https://pic.imgdb.cn/item/5f66f8f3160a154a67e1195a.jpg)](https://pic.imgdb.cn/item/5f66f8f3160a154a67e1195a.jpg)

 eden 区 与 from 区 的 比值 为 2 ∶ 1， 故 eden 区 为 512KB。 总可 用 新生代 大小 为 512KB+ 256KB= 768KB， 新生代 总大小 为 512KB+ 256KB+ 256KB= 1024KB= 1MB。

 由于 eden 区 无法 容纳 任何 一个 程序 中 分配 的 1MB 数组， 故 触发 了 一次 新生代 GC， 对 eden 区 进行 了 部分 回收。 同时， 这个 偏小 的 新生代 无法 为 1MB 数组 预留 空间， 故 所有 的 数组 都 分配 在 老 年代， 老年 代 最终 占用 10354KB 空间。

（2） 使用 参数- Xmx20m- Xms20m- Xmn7m- XX: SurvivorRatio= 2- XX:+ PrintGCDetails 运行 上述 程序， 将 新生代 扩大 为 7MB。

[![img](https://pic.imgdb.cn/item/5f66f952160a154a67e12fd9.jpg)](https://pic.imgdb.cn/item/5f66f952160a154a67e12fd9.jpg)

 在这 个 参数 下， 由于 eden 区 有 足够 的 空间， 因此 所有 的 数组 都 分配 在 eden 区。 但 eden 区 并不 足以 预留 10MB 的 空间， 故在 程序 运行 期间 出现 了 3 次 新生代 GC。 由于 每 申请 一次 空间， 同时 也 废弃 了 上一次 申请 的 空间（ 上一次 申请 的 内存 失去 了 引用）， 故在 新生代 GC 中， 有效 回收 了 这些 失效 的 内存。 最终 结果是： 所有 的 内存 分配 都在 新生代 进行， 通过 GC 保证 了 新生代 有 足够 的 空间， 而 老年 代 没有 为 这些 数组 预留 任何 空间， 只是 在 GC 过程中， 部分 新生代 对象 晋升 到 老 年代。

（3） 使用 参数- Xmx20m- Xms20m- Xmn15m- XX: SurvivorRatio= 8- XX:+ PrintGCDetails 运行

[![img](https://pic.imgdb.cn/item/5f66f983160a154a67e13bb6.jpg)](https://pic.imgdb.cn/item/5f66f983160a154a67e13bb6.jpg)

 在这 次 执行 中， 由于 新生代 使用 15MB 空间， 其中 eden 区 占用 了 12288KB， 完全 满足 10MB 数组 的 分配， 因此 所有 的 分配 行为 都在 eden 区 直接进行， 且 没有 触发 任何 GC 行为。 因此 from/ to 和 老 年代 tenured 的 使用 率 都为 0。

 在实际工作中，应该根据系统特点做合理设置，基本策略是：尽可能将对象预留在新生代，减少老年代GC的次数。

 除了可以使用参数-Xmn指定新生代的大小，还可以试用参数-XX:NewRatio来设置新生代和老年代的比例。

[![img](https://pic.imgdb.cn/item/5f66f9ed160a154a67e15329.jpg)](https://pic.imgdb.cn/item/5f66f9ed160a154a67e15329.jpg)

[![img](https://pic.imgdb.cn/item/5f66fa5e160a154a67e16d56.jpg)](https://pic.imgdb.cn/item/5f66fa5e160a154a67e16d56.jpg)

### 3.2.3 堆溢出处理

 如果堆空间不足，则有可能OOM。

 如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，要获取尽可能多的现场信息，以帮助研发人员排查问题。

 提供了参数-XX:+HeapDumpOnOutOfMemeoryError，可以在内存溢出时导出整个堆的信息。可以配合使用的还有-XX:HeapDumpPath。

 除了在OOM导出堆信息，还允许在发生错误时执行一个脚本。可以用于崩溃的程序自救、报警或通知。可以帮助开发人员获得更多的系统信息，比如完整的系统转存文件。

[![img](https://pic.imgdb.cn/item/5f66fb8a160a154a67e1b492.jpg)](https://pic.imgdb.cn/item/5f66fb8a160a154a67e1b492.jpg)

## 3.3 别让性能有缺口：了解非堆内存的参数配置

### 3.3.1 方法区配置

 方法 区 主要 存放 类 的 元 信息。 在 JDK 1. 6 和 JDK 1. 7 等 版本 中， 可以 使用- XX: PermSize 和- XX: MaxPermSize 配置 永久 区 大小。 其中，- XX: PermSize 表示 初始 的 永久 区 大小，- XX: MaxPermSize 表示 最大 永久 区 大小。

 从 JDK 1. 8 开始， 永久 区 被 彻底 移 除， 使用 了 新的 元 数据区 存放 类 的 元 数据。 在 默认 情况下， 元 数据区 只 受 系统 可用 内存 的 限制， 但 依然 可以 使用 参数- XX: MaxMetaspaceSize 指定 永久 区 的 最大 可用 值。 方法 区 的 详细 使用 和 配置 可以 参考 2. 5 节。

### 3.3.2 栈配置

 可以用-Xss参数指定线程的栈大小。

### 3.3.3 直接内存配置

 武断 地 认为 使用 直接 内存 一定 可以 提高 内存 访问 速度 也是 不正确 的。

 最大 可用 直接 内存 可以 使用 参数- XX: MaxDirectMemorySize 设置， 如果不 设置， 默认值 为最 大堆 空间， 即- Xmx 的 值。 当 直接 内存 使用 量 达到- XX: MaxDirectMemorySize 时， 就会 触发 垃圾 回收， 如果 垃圾 回收 不能 有效 释放 足够 的 空间， 直接 内存 溢出 依然 会 引起 系统 的 OOM。

 虽然 在 访问 读写 上 直接 内存 有 较大 的 优势， 但是 在内 存 空间 申请 时， 直接 内存 毫无 优势 可言。在 申请 内存 空间 时， 堆 空间 的 速度 远远 快于 直接 内存。

 结论： 直接 内存 适合 申请 次数 较少、 访问 较 频繁 的 场合。 如果 需要 频繁 申请 内存 空间， 则 并不 适合 使用 直接 内存。

## 3.4 Client和Server二选一：虚拟机工作模式

 参数-client指定Client模式，-server指定server模式。

 与 Client 模式 相比， Server 模式 的 启动 比较慢， 因为 Server 模式 会 尝试 收集 更多 的 系统 性能 信息， 使用 更 复杂 的 优化 算法 对 程序 进行 优化。因此， 当 系统 完全 启动 并进 入 运行 稳 定期 后， Server 模式 的 执行 速度 会 远远 快于Client 模式。 所以， 对于 后台 长期 运行 的 系统 来说， 使用- server 参数 启动 对 系统 的 整体 性能 可以 有不 小的 帮助。 但对 于 用户 界面 程序 而言， 运行 时间 不长， 又 追求 启动 速度， Client 模式 也是 不错 的 选择。

 在64位系统中，虚拟机更倾向于使用Server模式。

 虚拟 机 在 Server 模式 和 Client 模式 下 的 各种 参数 可能 会有 很大 的 不同， 读者 如果 需要 查看 给定 参数 的 默认值， 可以 使用- XX:+ PrintFlagsFinal 参数。 这里 以 JIT 编译 阈值 和 最大 堆 为例， 展示 Client 模式 和 Server 模式 的 区别。

 在 Client 模式 下， CompileThreshold 的 默认值 为 1500， 即 函数 被 调用 1500 次 后， 会 进行 JIT 编译（ 有关 JIT 编译 的 更多 细节 请参阅 第 11 章）。 而在 Server 模式 下， 这个 数值 为 10000。 因此， 在 Server 模式 下 系统 更有 可能 解释 执行。 而 一旦 进行 编译， Server 模式 的 优化 效果 会好 于 Client 模式。 对于 系统 最 大堆， 在 Client 模式 下 为 约 256MB， 而在 Server 模式 下 约为 1GB。

# 第4章 垃圾回收的概念与算法

知识点：

- 了解什么是垃圾回收
- 学习几种常用的垃圾回收算法
- 掌握可触及的概念
- 理解Stop-The-World(STW)

## 4.1 内存管理清洁工：认识垃圾回收

 开发人员只需要关注内存的申请，而内存的释放由系统自动识别和完成。

## 4.2 清洁工具打PK：讨论常用的垃圾回收算法

### 4.2.1 引用计数法(Reference Counting)

 有两个问题：

(1) 无法处理循环引用

(2) 引用计算器要求在每次引用产生和消除的时候，伴随一个加法操作和一个减法操作，对系统性能有一定影响。

[![img](https://pic.imgdb.cn/item/5f68960a160a154a679c2ec7.jpg)](https://pic.imgdb.cn/item/5f68960a160a154a679c2ec7.jpg)

### 4.2.2 标记清除算法(Mark-Sweep)

 分为两个阶段：标记阶段和清除阶段。

 在标记阶段，首先通过根节点标记所有从根节点开始的可达对象。然后在清除节点，清除所有未被标记的对象。标记清除的最大问题是可能产生空间碎片。

[![img](https://pic.imgdb.cn/item/5f68996a160a154a679f1344.jpg)](https://pic.imgdb.cn/item/5f68996a160a154a679f1344.jpg)

### 4.2.3 复制算法(Copying)

 核心思想是：将原有内存空间分成两块，每次使用其中一块，在进行垃圾回收时，将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

 代价是将内存折半。

[![img](https://pic.imgdb.cn/item/5f689a09160a154a679f960f.jpg)](https://pic.imgdb.cn/item/5f689a09160a154a679f960f.jpg)

 在新生代串行垃圾回收器中，使用了复制算法思想。新生代分为eden区、from区和to区。from区和to区也称为survivor区，用于存放未被回收的对象。

- 新生代： 存放 年轻 对象 的 堆 空间。 年轻 对象 指 刚刚 创建 的 或者 经历 垃圾 回收 次数 不多 的 对象。
- 老 年代： 存放 老年 对象 的 堆 空间。 老年 对象 指 经历 多次 垃圾 回收 后 依然 存活 的 对象。

 在 进行 垃圾 回收 时， eden 区 的 存活 对象 会被 复制 到 未使 用的 survivor 区（ 假设 是 to 区）， 正在 使用 的 survivor 区（ 假设 是 from） 的 年轻 对象 也会 被 复制 到 to 区（ 大 对象 或者 老年 对象 会 直接 进入 老 年代， 如果 to 区 已满， 则 对象 也会 直接 进入 老 年代）。 此时， eden 区 和 from 区 的 剩余 对象 就是 垃圾 对象， 可以 直接 清空， to 区 则 存放 此次 回收 后的 存活 对象。 这种 改进 的 复制 算法， 既 保证 了 空间 的 连续性， 又 避免 了 大量 的 内存 空间 浪费，

[![img](https://pic.imgdb.cn/item/5f689c3c160a154a67a169f9.jpg)](https://pic.imgdb.cn/item/5f689c3c160a154a67a169f9.jpg)

注意： 复制 算法 比较 适合 新生代， 因为 在 新生代 垃圾 对象 通常 会 多于 存活 对象， 复制 算法 的 效果 会 比较 好。

### 4.2.4 标记压缩算法(Mark-Compact)

 也叫标记整理算法。

 由于 存活 对象 较多， 复制 的 成本 将 很高。

 标记 压缩 法 是一 种 老 年代 的 回收 算法。 它在 标记 清 除法 的 基础上 做了 一些 优化。 和 标记 清除 法 一样， 标记 压缩 法 首先 也需 要从 根 节点 开始， 对 所有 可达 对象 做 一次 标记。 但 之后， 它 并不 只是 简单 地 清理 未标 记的 对象， 而是 将 所有 的 存活 对象 压缩 到 内存 的 一端。 然后， 清理 边界 外 所有 的 空间。 这种 方法 既 避免 了 碎片 的 产生， 又不 需要 两块 相同 的 内存 空间， 性 价 比 较高。

[![img](https://pic.imgdb.cn/item/5f689ca0160a154a67a1bbb9.jpg)](https://pic.imgdb.cn/item/5f689ca0160a154a67a1bbb9.jpg)

标记 压缩 法 的 最终 效果 等同 于 标记 清除 法 执行 完成 后再 进行 一次 内存 碎片 整理， 因此， 也可以 把 它 称为 标记 清除 压缩 法。

### 4.2.5 分代算法(Generational Collecting)

 分代算法将内存区间根据对象的特点分成几块，根据每块内存的区间的特点使用不同的回收算法，以提高垃圾回收效率。

[![img](https://pic.imgdb.cn/item/5f689e46160a154a67a313df.jpg)](https://pic.imgdb.cn/item/5f689e46160a154a67a313df.jpg)

 通常 新生代 回收 的 频率 很高， 但是 每次 回收 的 耗时 很短， 而 老年 代 回收 的 频率 比 较低， 但是 会 消耗 更多 的 时间。 为了 支持 高频率 的 新生代 回收， 虚拟 机 可能 使用 一种 叫作 卡 表（ Card Table） 的 数据 结构。 卡 表为 一个 比特 位 集合， 每一个 比特 位 可以 用来 表示 老 年代 的 某一 区域 中的 所有 对象 是否 持有 新生代 对象 的 引用。

 这样 在 新生代 GC 时， 可以 不用 花 大量 时间 扫描 所有 的 老年 代 对象 来 确定 每一个 对象 的 引用 关系， 可以 先 扫描 卡 表， 只有 当 卡 表 的 标记 位 为 1 时， 才 需要 扫描 给定 区域 的 老年 代 对象， 而 卡 表 位 为 0 的 老年 代 对象， 一定 不 含有 新生代 对象 的 引用。

[![img](https://pic.imgdb.cn/item/5f689ead160a154a67a3738c.jpg)](https://pic.imgdb.cn/item/5f689ead160a154a67a3738c.jpg)

### 4.2.6 分区算法(Region)

 分 代 算法 将 按照 对象 的 生命 周期 长短 划分 成 两个 部分， 分区 算法 将 整个 堆 空间 划分 成 连续 的 不同 小 区间。

 所示。 每一个 小 区间 都 独立 使用， 独立 回收。 这种 算法 的 好处 是 可以 控制 一次 回收 小区 间的 数量。

 在 相同 条件下， 堆 空间 越大， 一次 GC 所需 要的 时间 就 越长， 从而 产生 的 停顿 也 越长（ GC 产生 的 停顿 请 参见 4. 4 节）。 为了 更好 地 控制 GC 产生 的 停顿 时间， 将 一块 大的 内存 区域 分割 成 多个 小块， 根据 目标 停顿 时间， 每次 合理 地 回收 若干个 小 区间， 而 不是 回收 整个 堆 空间， 从而 减少 一次 GC 所 产生 的 停顿。

[![img](https://pic.imgdb.cn/item/5f68a036160a154a67a46732.jpg)](https://pic.imgdb.cn/item/5f68a036160a154a67a46732.jpg)

## 4.3 谁才是真正的垃圾：判断可触及性

 垃圾 回收 的 基本 思想 是 考查 每一个 对象 的 可 触及 性， 即从 根 节点 开始 是否 可以 访问 这个 对象， 如果 可以， 则 说明 当前 对象 正在 被 使用， 如果 从 所 有的 根 节点 开始 都无 法 访问 到 某个 对象， 说明 该 对象 已经 不再 使用 了， 一般来说， 该 对象 需要 被 回收。 但 事实上， 一个 无法 触及 的 对象 有可 能在 某个 条件下 使 自己“ 复活”， 如果 是 这样 的 情况， 那么 对 它的 回收 就是 不合理 的， 为此， 需要 给出 一个 对象 可触 及 性 状态 的 定义， 并 规定 在什么 状态 下 才可 以 安全 地 回收 对象。

- 可触及的：从根节点，可以到达这个对象。
- 可符合的：对象的所有引用都被释放，但是对象有可能在finalize()函数中复活。
- 不可触及的：对象的finalize()函数被调用，并没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为finalize()函数只会被调用一次。

### 4.3.1 对象的复活

 对象有可能在finalize函数中使自己复活。

 注意： finalize() 函数 是一 个 非常 糟糕 的 模式， 不 推荐 读者 使用 finalize() 函数 释放 资源。

 第一， 因为 finalize() 函数 有可能 发生 引用 外 泄， 在 无意中 复活 对象；

 第二， 由于 finalize() 函数 是 被 系统 调用 的， 调用 时间 是 不明确 的， 因此 不是 一个 好的 资源 释放 方案， 推荐 在 try- catch- finally 语句 中进 行 资源 的 释放。

### 4.3.2 引用和可触及性的强度

 在 Java 中 提供 了 4 个 级别 的 引用： 强 引用、 软 引用、 弱 引用 和 虚 引用。 除 强 引用 外， 其他 3 种 引用 均可 以在 java. lang. ref 包 中 找到。

 其中 FinalReference 为“ 最终” 引用， 它 用以 实现 对象 的 finalize（） 函数（

 强 引用 就是 程序 中 一般 使用 的 引用 类型， 强 引用 的 对象 是 可 触及 的， 不会 被 回收。 软 引用、 弱 引用 和 虚 引用 的 对 象是 软 可 触及、 弱 可 触及 和 虚 可 触及 的， 在 一定 条件下 都是 可以 被 回收 的。

强 引用 具备 以下 特点：

- 强 引用 可以 直接 访问 目标 对象。
- 强 引用 所 指向 的 对象 在 任何时候 都不 会被 系统 回收， 虚拟 机 宁愿 抛出 OOM 异常， 也不 会 回收 强 引用 所 指向的 对象。
- 强 引用 可能 导致 内存 泄漏。

### 4.3.3 软引用——可被回收的引用

软 引用 是 比 强 引用 弱 一点 的 引用 类型。 如果 一个 对象 只 持有 软 引用， 那么 当 堆 空间 不足 时， 就会 被 回收。 软 引用 使用 java. lang. ref. SoftReference 类 实现。

每一个 软 引用 都可以 附带 一个 引用 队列， 当 对象 的 可达 性 发生 改变 时（ 由 可达 变为 不 可达）， 软引用 对象 就会 进入 引用 队列。 通过 这个 引用 队列， 可以 跟踪 对象 的 回收 情况。

[![img](https://pic.imgdb.cn/item/5f68a826160a154a67aaf771.jpg)](https://pic.imgdb.cn/item/5f68a826160a154a67aaf771.jpg)

### 4.3.4 弱引用——发现即回收

 弱 引用 是 一种 比 软 引用 弱 的 引用 类型。 在 系统 GC 时， 只要 发现 弱 引用， 不管 系统 堆 空间 使用 情况 如何， 都会 将对 象 进行 回收。 但是， 由于 垃圾 回收 器 的 线程 通常 优先级 很低， 并不 一定 能 很快 地 发现 持有 弱 引用 的 对象。 在 这种 情况下， 弱 引用 对象 可以 存在 较长 的 时间。 一旦 一个 弱 引用 对象 被 垃圾 回收 器 回收， 便会 加入 一个 注册 的 引用 队列（ 这一点 和 软 引用 很像）。 弱 引用 使用 java. lang. ref. WeakReference 类 实现。

 弱 引用 和 软 引用 一样， 在 构造 弱 引用 时， 也可以 指定 一个 引用 队列， 当 弱 引用 对象 被 回收 时， 就会 加入 指定 的 引用 队列， 通过 这个 队列 可以 跟踪 对象 的 回收 情况。

注意： 软 引用、 弱 引用 都 非常 适合 保存 那些 可有可无 的 缓存 数据。 如果 这么 做， 当 系统 内存 不足 时， 这些 缓存 数据 会被 回收， 不会 导致 内存 溢出。 而 当 内存 资源 充足 时， 这些 缓存 数据 又可 以 存在 相当 长的 时间， 从而 起到 让 系统 加速 的 作用。

### 4.3.5 虚引用——对象回收跟踪

 虚 引用 是 所有 引用 类型 中 最弱 的 一个。 一个 持有 虚 引用 的 对象， 和 没有 引用 几乎 是 一样 的， 随时 都可 能被 垃圾 回收 器 回收。 当 试图 通过 虚 引用 的 get() 方法 取得 强 引用 时， 总会 失败。 并且， 虚 引用 必须 和 引用 队列 一起 使用， 它的 作用 在于 跟踪 垃圾 回收 过程。

 由于 虚 引用 可以 跟踪 对象 的 回收 时间， 所以 也可以 将 一些 资源 释放 操作 放在 虚 引用 中 执行 和 记录。

## 4.4 垃圾回收时的停顿现象：Stop-TheWorld实战

 垃圾 回收 器 的 任务 是 识别 和 回收 垃圾 对象， 以 进行 内存 清理。 为了 让 垃圾 回收 器 可以 正常 且 高效 地 执行， 在 大部分 情况下， 会要 求 系统 进入 一个 停顿 的 状态。 停顿 的 目的 是 终止 所有 应用 线程 的 执行， 只有 这样 系统 中 才不 会有 新的 垃圾 产生， 同时 停顿 保证 了 系统 状态 在某 一个 瞬间 的 一致性， 也有 益于 垃圾 回收 器 更好 地 标记 垃圾 对象。 因此， 在 垃圾 回收 时， 都会 产生 应用 程序 的 停顿。 停顿 产生 时， 整个 应用 程序 会被 卡 死， 没有 任何 响应， 因此 这个 停顿 也 叫作“ Stop- The- World”（ STW）。

 例子略。

# 第5章 垃圾收集器和内存分配

知识点：

- Java虚拟机支持的垃圾回收器种类
- 串行垃圾回收器
- 并行垃圾回收器
- CMS回收器
- G1回收器
- 有关对象分配的一些细节问题

## 5.1 一心一意一件事：串行回收器

串行回收器是指使用单线程进行垃圾回收的回收器。

对于 并行 能力 较弱 的 计算机 来说， 串行 回收 器 的 专注 性 和 独占 性 往往 能 让 其 有 更好 的 性能 表现。 串行 回收 器 可以 在 新生代 和 老年 代 使用， 根据 不同 的 堆 空间 分为 新生代 串行 回收 器 和 老年 代 串行 回收 器。

### 5.1.1 新生代串行回收器

两个特点

- 仅仅使用单线程进行垃圾回收
- 是独占式的垃圾回收方式。

在 串行 回收 器 进行 垃圾 回收 时， Java 应用 程序 中的 线程 都 需要 暂停 工作， 等待 垃圾 回收 完成。

[![img](https://pic.imgdb.cn/item/5f69f9e2160a154a67573d4c.jpg)](https://pic.imgdb.cn/item/5f69f9e2160a154a67573d4c.jpg)

 新生代 串行 回收 器 使用 复制 算法， 实现 相对 简单、 逻辑 处理 特别高 效 且 没有 线程 切换 的 开销。 在 诸如 单 CPU 处理器 等 硬件 平台 不是 特别 优越 的 情况下， 它的 性能 表现 可以 超过 并行 回收 器 和 并发 回收 器。

使用- XX:+ UseSerialGC 参数 可以 指定 使用 新生代 串行 回收 器 或 老年 代 串行 回收 器。 当 虚拟 机 在 Client 模式 下 运行时， 它是 默认 的 垃圾 回收 器。

注意：串行 垃圾 回收 器 虽然 古老， 但是 久经考验， 在 大多数 情况下， 其 性能 表现 是 相当 不错 的。

### 5.1.2 老年代串行回收器

作为 老牌 的 垃圾 回收 器， 老年 代 串行 回收 器 可以 和 多种 新生代 回收 器 配合 使用， 同时 它 也可以 作为 CMS 回收 器 的 备用 回收 器。

- -XX：+ UseSerialGC： 新生代、 老 年代 都 使用 串行 回收 器。
- -XX：+ UseParNewGC（ JDK 9、 JDK 10 已经 删除， 因为 ParNew 需要 和 CMS 搭配 工作， 而 CMS 已经 被 G1 替代， 不再 支持 此 参数）： 新生代 使用 ParNew 回收 器， 老年 代 使用 串行 回收 器。
- -XX：+ UseParallelGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 串行 回收 器。

## 5.2 人多力量大：并行回收器

### 5.2.1 新生代ParNew回收器

它 只是 简单 地 将 串行 回收 器 多 线程 化， 它的 回收 策略、 算法 及 参数 和 新生代 串行 回收 器 一样。

[![img](https://pic.imgdb.cn/item/5f69fabc160a154a6757a32c.jpg)](https://pic.imgdb.cn/item/5f69fabc160a154a6757a32c.jpg)

- -XX：+ UseParNewGC（ JDK 9、 JDK 10 已经 删除， 因为 ParNew 需要 和 CMS 搭配 工作， 而 CMS 已经 被 G1 替代， 不再 支持 此 参数）： 新生代 使用 ParNew 回收 器， 老年 代 使用 串行 回收 器。
- -XX：+ UseConcMarkSweepGC（ JDK 9、 JDK 10 不 建议 使用， 建议 使用 默认 的 G1 垃圾 回收 器）： 新生代 使用 ParNew 回收 器， 老年 代 使用 CMS。

 ParNew 回收 器 工作 时 的 线程 数量 可以 使用- XX: ParallelGCThreads 参数 指定。 一般， 最好 与 CPU 数量 相当， 避免 过多 的 线程 数 影响 垃圾 回收 性能。 在 默认 情况下， 当 CPU 数量 小于 8 时， ParallelGCThreads 的 值 等于 CPU 数量， 当 CPU 数量 大于 8 时， ParallelGCThreads 的 值 等于 3+(( 5 × CPU_ Count)/ 8)。

### 5.2.2 新生代ParallelGC回收器

 从 表面 上看， 它 和 ParNew 回收 器 一样， 都是 多 线程、 独占 式 的 回收 器。 但是， ParallelGC 回收 器 有一个 重要的 特点： 它 非常 关注 系统 的 吞吐量。

- -XX：+ UseParallelGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 串行 回收 器。
- -XX：+ UseParallelOldGC： 新生代 使用 ParallelGC 回收 器， 老年 代 使用 ParallelOldGC 回收 器。

ParallelGC 回收 器 提供 了 两个 重要的 参数 用于 控制系统 的 吞吐量。

- -XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。 它的 值 是一 个大 于 0 的 整数。 ParallelGC 在 工作 时， 会 调整 Java 堆 大小 或者 其他 参数， 尽可能 地 把 停顿 时间 控制 在 MaxGCPauseMillis 以内。 如果 读者 希望 减少 停顿 时间 而 把 这个 值 设 得很 小， 为了 达到 预期 的 停顿 时间， 虚拟 机 可能 会使 用 一个 较 小的 堆（ 一个 小堆 比 一个 大堆 回收 快）， 而这 将 导致 垃圾 回收 变得 很 频繁， 从而 增加 垃圾 回收 总 时间， 降低 吞吐量。
- -XX： GCTimeRatio： 设置 吞吐量 大小。 它的 值 是 一个 0 到 100 之间 的 整数。 假设 GCTimeRatio 的 值 为 n， 那么 系统 将 花费 不超过 1/（ 1+ n） 的 时间 进行 垃圾 回收。 比如 GCTimeRatio 等于 19（ 默认值）， 则 系统 用于 垃圾 回收回收 的 时间 不超过 1/（ 1+ 19）= 5%。 默认 情况下， 它的 取值 是 99， 即有 不超过 1/（ 1+ 99）= 1% 的 时间 用于 垃圾 回收。

 还 支持 一种 自 适应 的 GC 调节 策略。 使用- XX:+ UseAdaptiveSizePolicy 可以 打开 自 适应 GC 策略。 在这 种 模式 下， 新生代 的 大小、 eden 区 和 survivor 区 的 比例、 晋升 老 年代 的 对象 年龄 等 参数 会被 自动 调整， 以 达到 在 堆 大小、 吞吐量 和 停顿 时间 之间 的 平衡 点。

### 5.2.3 老年代ParallelOldGC会后器

 ParallelOldGC 回收 器 使用 标记 压缩 法， 它在 JDK1. 6 中 才可 以 使用。

[![img](https://pic.imgdb.cn/item/5f69fd2a160a154a6758af56.jpg)](https://pic.imgdb.cn/item/5f69fd2a160a154a6758af56.jpg)

使用- XX:+ UseParallelOldGC 可以 在 新生代 使用 ParallelGC 回收 器， 老年 代 使用 ParallelOldGC 回收 器。

参数- XX: ParallelGCThreads 也可以 用于 设置 垃圾 回收 时 的 线程 数量。

## 5.3 一心多用都不落下：CMS回收器(JDK8及之前的版本)

### 5.3.1 CMS主要工作步骤

 CMS 工作 时 的 主要 步骤 有： 初始 标记、 并发 标记、 预 清理、 重新 标记、 并发 清除 和 并发 重置。

[![img](https://pic.imgdb.cn/item/5f69fddf160a154a6759083d.jpg)](https://pic.imgdb.cn/item/5f69fddf160a154a6759083d.jpg)

 根据 标记 清除 法， 初始 标记、 并发 标记 和 重新 标记 都是 为了 标记 出 需要 回收 的 对象。 并发 清理 则是 在 标记 完成 后， 正式 回收 垃圾 对象。 并发 重置 是指 在 垃圾 回收 完成 后， 重新 初始化 CMS 数据 结构 和 数据， 为 下一 次 垃圾 回收 做好 准备。 并发 标记、 并发 清理 和 并发 重置 都是 可以 和 应用 程序 线程 一起 执行 的。

```
默认 情况下， 在 并发 标记 之后， 会有 一个 预 清理 的 操作（ 也可以 关闭 开关- XX:- CMSPrecleaningEnabled， 不 进行 预 清理）。 预 清理 是 并发 的， 除了 为 正式 清理 做 准备 和 检查， 还会 尝试 控制 一次 停顿 的 时间。 由于 重新 标记 是 独占 CPU 的， 如果 新生代 GC 发 生后， 立即 触发 一次 重新 标记， 那么 一次 停顿 的 时间 可能 很长。 为了 避免 这种 情况， 预处理 时会 刻意 等待 一次 新生代 GC 的 发生， 然后 根据 历史 性能 数据 预测 下 一次 新生代 GC 可能发生 的 时间， 在当 前 时间 和 预测 时间 的 中间 时刻 进行 重新 标记。 这样 可 尽量 避免 新生代 GC 和 重新 标记 重合， 尽可能 减少 一次 停顿 的 时间。
```

### 5.3.2 CMS主要的参数

 启用 CMS 回收 器 的 参数 是- XX:+ UseConcMarkSweepGC。设置 合理 的 工作 线程 数量 对 系统性 能有 重要的 影响。

 CMS 默认 启动 的 并发 线程 数 是( ParallelGCThreads+ 3)/ 4。 ParallelGCThreads 表示 GC 并行 时 使用 的 线程 数量，如果 新生代 使用 ParNew， 那么 ParallelGCThreads 也就是 新生代 GC 的 线程 数量。 这 意味着 有 4 个 ParallelGCThreads 时， 只有 1 个 并发 线程， 而有 两个 并发 线程 时， 有 5~ 8 个 ParallelGCThreads 线程。

 并发 线程 数量 也可以 通过- XX: ConcGCThreads 或者- XX: ParallelCMSThreads 参数 手工 设定。 当 CPU 资源 比较 紧张 时， 受到 CMS 回收 器 线程 的 影响， 应用 系统 的 性能 在 垃圾 回收 阶段 可能 会 非常 糟糕。

 CMS 回收 器 不会 等待 堆 内存 饱和 时 才 进行 垃圾 回收， 而是 当 堆 内存 使用 率 达到 某一 阈值 时 便 开始 进行 回收， 以 确保 应用 程序 在 CMS 工作 过程中， 依然 有 足够 的 空间 支持 应用 程序 运行。

 使用 参数- XX: CMSInitiatingOccupancyFraction 来 指定， 默认 是 68， 即 当 老 年代 的 空间 使用 率 达到 68% 时， 会 执行 一次 CMS 回收。 如果 应用 程序 的 内存 使用 率 增长 很快， 在 CMS 的 执行 过程中， 已经 出现 了 内存 不足 的 情况， CMS 回收 就会 失败， 虚拟 机 将 启动 老年 代 串行 回收 器 进行 垃圾 回收。

 如果 内存 增长 缓慢， 则 可以 设置 一个 稍 大的 值， 大的 阈值 可以 有效 降低 CMS 的 触发 频率， 减少 老年 代 回收 的 次数， 可以 较为 明显 地 改善 应用 程序 性能。 反之， 如果 应用 程序 内存 使用 率 增长 很快， 则应 该 降低 这个 阈值， 以 避免 频繁 触发 老年 代 串行 回收 器。

[![img](https://pic.imgdb.cn/item/5f69ff4a160a154a6759d87c.jpg)](https://pic.imgdb.cn/item/5f69ff4a160a154a6759d87c.jpg)

 -XX:+ UseCMSCompactAtFullCollection 参数 可 以使 CMS 在 垃圾 收集 完成 后， 进行 一次 内存 碎片 整理， 内存 碎片 的 整理 不是 并发 进行 的。

 - XX: CMSFullGCsBeforeCompaction 参数 可以 用于 设定 进行 多少 次 CMS 回收 后， 进行 一次 内存 压缩。

### 5.3.3 CMS的日志分析

 略

### 5.3.4 有关Class的回收

 在 使用 CMS 回收 器 时， 如果 需要 回收 Perm 区， 那么 默认 情况下， 还需 要 触发 一次 Full GC。

 如果 希望 使用 CMS 回收 器 回收 Perm 区， 则 必须 打开- XX:+ CMSClassUnloadingEnabled 开关。 使用- XX:+ CMSClassUnloadingEnabled 后， 如果 条件 允许， 系统 会 使用 CMS 的 机制 回收 Perm 区 的 Class 数据，

## 5.4 未来我做主:G1回收器(JDK9及之后版本的默认回收器)

G1 使用 了 全新 的 分区 算法， 其 特点 如下。

- 并行 性： G1 在 回收 期间， 可以 由 多个 GC 线程 同时 工作， 有效 利用 多 核计 算 能力。
- 并发 性： G1 拥有 与 应用 程序 交替 执行 的 能力， 部分 工作 可以 和 应用 程序 同时 执行， 一般来说， 不会 在 整个 回收 期间 完全 阻塞 应用 程序。
- 分 代 GC： G1 依然是 一个 分 代 回收 器， 但是 和 之前 的 回收 器 不同， 它 同时 兼顾 年轻 代 和 老 年代， 其他 回收 器 或者 工作 在 年轻 代， 或者 工作 在 老 年代。
- 空间 整理： G1 在 回收 过程中， 会 进行 适当 的 对象 移动， 不像 CMS， 只是 简单 地 标记 清理 对象， 在 若干 次 GC 后， CMS 必须 进行 一次 碎片 整理。 而 G1 不同， 它 每次 回收 都会 有效地 复制 对象， 减少 碎片 空间。
- 可 预见性： 由于 分区 的 原因， G1 可以 只 选取 部分 区域 进行 内存 回收， 这样 缩小 了 回收 的 范围， 全局 停顿 也能 得到 较好 的 控制。

### 5.4.1 G1的内存划分和主要收集过程

 G1 将 堆 进行 分区， 划分 为 一 个个 的 区域， 每次 回收 的 时候， 只 回收 其中 几个 区域， 以此 来 控制 垃圾 回收 产生 的 一次 停顿 的 时间。

 回收过程有4个阶段：

- 新生代 GC。
- 并发 标记 周期。
- 混合 回收。
- 如果 需要， 可能 会 进行 Full GC。

### 5.4.2 G1的新生代GC

 新生代 GC 的 主要 工作 是 回收 eden 区 和 survivor 区。 一旦 eden 区 被占 满， 新生代 GC 就会 启动。E 表示 eden 区， S 表示 survivor 区， O 表示 老 年代。 可以 看到， 新生代 GC 只 处理 eden 区 和 survivor 区， 回收 后 所有 的 eden 区 都 应该 被 清空， 而 survivor 区 会被 回收 一部分 数据， 但是 应该 至少 仍然 存在 一个 survivor 区。

 另一个 重要的 变化 是， 老 年代 的 区域 增多， 因为 部分 survivor 区 或者 eden 区 的 对象 可能 会 晋升 到 老 年代。

[![img](https://pic.imgdb.cn/item/5f6a016c160a154a675b1bc4.jpg)](https://pic.imgdb.cn/item/5f6a016c160a154a675b1bc4.jpg)

### 5.4.3 G1的并发标记周期

 分为以下几步：

- 初始 标记： 标记 从 根 节点 直接 可达 的 对象。 这个 阶段 会 伴随 一次 新生代 GC， 它是 会 产生 全局 停顿 的， 应用 程序 线程 在这 个 阶段 必须 停止 执行。
- 根 区域 扫描： 由于 初始 标记 必然会 伴随 一次 新生代 GC， 所以 在 初始化 标记 后， eden 区 被 清空， 并且 存活 对象 被 移入 survivor 区。 在这 个 阶段， 将 扫描 由 survivor 区 直接 可达 的 老年 代 区域， 并 标记 这些 直接 可达 的 对象。 这个 过程 是 可以 和 应用 程序 并发 执行 的。 但是 根 区域 扫描 不能 和 新生代 GC 同时 执行（ 因为 根 区域 扫描 依赖 survivor 区 的 对象， 而 新生代 GC 会 修改 这个 区域）， 因此 如果 恰巧 在此 时 需要 进行 新生代 GC， 就 需要 等待 根 区域 扫描 结束 后才 能 进行。 如果 发生 这种 情况， 这次 新生代 GC 的 时间 就会 延长。
- 并发 标记： 和 CMS 类似， 并发 标记 将会 扫描 并 查找 整个 堆 的 存活 对象， 并 做好 标记。 这是 一个 并发 的 过程， 并且 这个 过程 可以 被 一次 新生代 GC 打断。
- 重新 标记： 和 CMS 一样， 重新 标记 也是 会 产生 应用 程序 停顿 的。 由于 在 并发 标记 过程中， 应用 程序 依然 在 运行， 因此 标记 结果 可能 需要 进行 修正， 所以 在此 对上 一次 的 标记 结果 进行 补充。 在 G1 中， 这个 过程 使用 SATB（ Snapshot- At- The- Beginning） 算法 完成， 即 G1 会在 标记 之初 为 存活 对象 创建 一个 快照， 这个 快照 有助于 加速 重新 标记 的 速度。
- 独占 清理： 这个 阶段 是 会 引起 停顿 的。 它将 计算 各个 区域 的 存活 对象 和 GC 回收 比例， 并进 行 排序， 识别 可供 混合 回收 的 区域。 在这 个 阶段， 还会 更新 记忆 集（ Remebered Set）。 该 阶段 给出 了 需要 被 混合 回收 的 区域 并进 行了 标记， 在 混合 回收 阶段 需要 这些 信息。
- 并发 清理： 这里 会 识别 并 清理 完全 空闲 的 区域。 它是 并发 的 清理， 不会 引起 停顿。

 并发 标记 周期 执行 前后 最大 的 不同 是在 该 阶段 后， 系统 增加 了 一些 标记 为 G 的 区域。 这些 区域 被 标记， 是因为 它们 内部 的 垃圾 比例 较高， 希望 在 后续 的 混合 GC 中进 行 收集（ 注意 在 并发 标记 周期 中 并未 正式 收集 这些 区域）。 这些 将要 被 回收 的 区域 会被 G1 记录 在 一个 称为 Collection Sets（ 回收 集） 的 集合 中。

[![img](https://pic.imgdb.cn/item/5f6a02a1160a154a675bd3d5.jpg)](https://pic.imgdb.cn/item/5f6a02a1160a154a675bd3d5.jpg)

[![img](https://pic.imgdb.cn/item/5f6a02b2160a154a675bdddd.jpg)](https://pic.imgdb.cn/item/5f6a02b2160a154a675bdddd.jpg)

### 5.4.4 混合回收

 在这 个 阶段 既 会 执行 正常 的 年轻 代 GC， 又会 选取 一些 被 标记 的 老年 代 区域 进行 回收， 它 同时 处理 了 新生代 和 老 年代， 如图 5. 9 所示。 因为 新生代 GC 的 原因， eden 区 必然 被 清空， 此外， 有 两块 被 标记 为 G 的 垃圾 比例 最高 的 区域 被 清理。 被 清理 区域 中的 存活 对象 会被 移到 其他 区域， 这样做 的 好处 是 可以 减少 空间 碎片。

[![img](https://pic.imgdb.cn/item/5f6a0303160a154a675c110f.jpg)](https://pic.imgdb.cn/item/5f6a0303160a154a675c110f.jpg)

 混合 GC 会 执行 多次， 直到 回收 了 足够 多的 内存 空间， 然后 它 会 触发 一次 新生代 GC。 新生代 GC 后， 又 可能 会 发生 一次 并发 标记 周期 的 处理， 最后 又会 引起 混合 GC 的 执行。

[![img](https://pic.imgdb.cn/item/5f6a0320160a154a675c2354.jpg)](https://pic.imgdb.cn/item/5f6a0320160a154a675c2354.jpg)

### 5.4.5 必要时的Full GC

 不能 完全避免 在 特别 繁忙 的 场合 出现 在 回收 过程中 内存 不充足 的 情况。 当 遇到 这种 情况 时， G1 也会 转入 一个 Full GC。

### 5.4.6 G1的日志

略。

 记忆 集 是 G1 中 维护 的 一个 数据 结构， 简称 RS。 每一个 G1 区域 都有 一个 RS 与之 关联。 由于 G1 回收 时 是按 照 区域 回收 的， 比如 在 回收 区域 A 的 对象 时， 很可能 并不 回收 区域 B 的 对象， 为了 回收 区域 A 的 对象， 要 扫描 区域 B 甚至 整个 堆 来 判定 区域 A 中 哪些 对象 不 可达， 这样做 的 代价 显然 很大。 因此， G1 在 区域 A 的 RS 中， 记录 了 在 区域 A 中 被 其他 区域 引用 的 对象， 这样 在 回收 区域 A 时， 只要 将 RS 视为 区域 A 根 集 的 一部分 即可， 从而 避免 做 整个 堆 的 扫描。 由于 系统 在 运行 过程中， 对象 之间 的 引用 关系 是 可能 时刻 变化 的， 为了 更 高效 地 跟踪 这些 引用 关系， 会 将 这些 变化 记录 在 Update Buffers 中。 这里 的 Processed Buffers 指的 就是 处理 这个 Update Buffers 数据。

### 5.4.7 G1相关参数

 可以 使用- XX:+ UseG1GC 标记 打开 G1 的 开关， 对 G1 进行 设置 时， 最重要的 一个 参数 就是- XX: MaxGCPauseMillis， 它 用于 指定 目标 最大 停顿 时间。时间。 如果 任何 一次 停顿 超过 这个 设置 值， G1 就会 尝试 调整 新生代 和 老 年代 的 比例、 调整 堆 大小、 调整 晋升 年龄 等， 试图 达到 预设 目标。

 如果 停顿 时间 缩短， 对于 新生代 来说， 这 意味着 很可能 要 增加 新生代 GC 的 次数。 对于 老年 代 来说， 为了 获得 更短 的 停顿 时间， 在 混合 GC 时， 一次 收集 的 区域 数量 也会 变少， 这样 无疑 增加 了 进行 Full GC 的 可能性。

 另外 一个 重要的 参数 是- XX: ParallelGCThreads， 它 用于 设置 并行 回收 时 GC 的 工作 线程 数量。
​ 此外，- XX: InitiatingHeapOccupancyPercent 参数 可以 指定 当 整个 堆 使用 率 达到 多少 时， 触发 并发 标记 周期 的 执行。 默认值 是 45， 即 当 整个 堆 的 占用 率 达到 45% 时， 执行 并发 标记 周期。 InitiatingHeapOccupancyPercent 一旦 设置， 始终 都不 会被 G1 修改， 这 意味着 G1 不会 试图 改变 这个 值 来 满足 MaxGCPauseMillis 的 目标。 如果 InitiatingHeapOccupancyPercent 值 设置 得 偏大， 会 导致 并发 周期 迟迟 得不到 启动， 那么 引起 Full GC 的 可能性 也 大大 增加， 反之， 一个 过小 的 InitiatingHeapOccupancyPercent 值 会使 得 并发 标记 周期 执行 非常 频繁， 大量 GC 线程 抢占 CPU， 导致 应用 程序 的 性能 有所 下降。

## 5.5 回眸：有关对象内存分配和回收的一些细节问题

### 5.5.1 禁用System.gc()

 在 默认 情况下， System. gc() 会 显 式 直接 触发 Full GC， 同时 对 老 年代 和 新生代 进行 回收。 而 一般 情况下， 我们 认为 垃圾 回收 应该 是 自动 进行 的， 无须 手工 触发。 如果 过于 频繁 地 触发 垃圾 回收 对 系统性 能 是 没有 好处 的。 因此 虚拟 机 提供 了 一个 参数 DisableExplicitGC 来 控制 是否 手工 触发 GC。

 如果 设置 了- XX:-+ DisableExplicitGC， 条件 判断 就 无法 成立， 那么 就会 禁用 显 式 GC， System. gc() 等价 于 一个 空 函数 调用。

### 5.5.2 System.gc()使用并发回收

 在 默认 的 情况下， 即使 System. gc() 生效， 会使 用 传统 的 Full GC 方式 回收 整个 堆， 而 忽略 参数 中的 UseG1GC 和 UseConcMarkSweepGC。

 打开 虚拟 机 参数- XX:+ ExplicitGCInvokesConcurrent 后， 可以 改变 这种 默认 的 行为，

 只有 在 打开 ExplicitGCInvokesConcurrent 开关 后， System. gc() 这种 显 式 GC 才会 使用 并发 的 方式 进行 回收， 否则， 无论 是否 启用 了 CMS 或者 G1， 都不 会 进行 并发 回收。

### 5.5.3 并行GC前额外触发的新生代GC

 对于 并行 回收 器 的 Full GC（ 使用 UseParallelOldGC 或者 UseParallelGC），， 在 每一 次 Full GC 之前 都会 伴随 一次 新生代 GC。

 如果不 需要 这个 特性， 那么 可以 使用 参数- XX:- ScavengeBeforeFullGC 去除 发生 在 Full GC 之前 的 那次 新生代 GC。 在 默认 情况下， ScavengeBeforeFullGC 的 值 为 true。

### 5.5.4 对象何时进入老年代

#### 1. 初创的对象在eden区

 当 对象 首次 创建 时， 会被 放置 在 新生代 的 eden 区。当 对象 的 年龄 达到 一定 的 大小， 就 自然 可以 离开 年轻 代， 进入 老 年代。 一般 把 对象 进入 老 年代 的 事件， 称为“ 晋升”。

#### 3. 老年对象进入老年代

 对象 的 年龄 是由 对象 经历 过 的 GC 次数 决定 的。 在 新生代 中的 对象 每 经历 一次 GC， 如果 它 没有 被 回收， 它的 年龄 就 加 1。 虚拟 机 提供 了 一个 参数 来 控制 新生代 对象 的 最大 年龄： MaxTenuringThreshold。 在 默认 情况下， 这个 参数 的 值 为 15。 也就是说， 新生代 的 对象 最多 经历 15 次 GC， 就可以 晋升 到 老 年代。

 MaxTenuringThreshold 指的 是最 大 晋升 年龄。 它是 对象 晋升 到 老 年代 的 充分 非必要 条件。 即 达到 该 年龄， 对象 必然 晋升， 而未 达到 该 年龄， 对象 也有 可能 晋升。 事实上， 对象 的 实际 晋升 年龄， 是由 虚拟 机 在 运行时 自行 判断 的。

 计算晋升年龄的基本逻辑代码如下：

[![img](https://pic.imgdb.cn/item/5f6b3d5d160a154a67d76a1d.jpg)](https://pic.imgdb.cn/item/5f6b3d5d160a154a67d76a1d.jpg)

注意： 对象 的 实际 晋升 年龄 是 根据 survivor 区 的 使用 情况 动态 计算 得来 的， 而 MaxTenuringThreshold 只是 表示 这个 年龄 的 最大值。

#### 4. 大对象进入老年代

 除了 年龄， 对象 的 体积 也会 影响 对象 的 晋升。 试想， 如果 对象 体积 很大， 新生代 无论 eden 区 还是 survivor 区 都无 法 容纳 这个 对象， 自然 这个 对象 无法 存放 在 新生代， 也非 常有 可能 被 直接 晋升 到 老 年代。

 PretenureSizeThreshold， 它 用来 设置 对象 直接 晋升 到 老 年代 的 阈值， 单位 是 字节。 只要 对象 的 大小 大于 指定 值， 就会 绕过 新生代， 直接 在 老年 代 分配。 这个 参数 只对 串行 回收 器 和 ParNew 有效， 对于 ParallelGC 无效。 默认 情况下 该 值 为 0， 也就是 不 指定 最大 的 晋升 大小， 一切 由 运行 情况 决定。

### 5.5.5 在TLAB上分配对象

 TLAB 的 全称 是 Thread Local Allocation Buffer， 即 线程 本地 分配 缓存。 从 名字 上 可以 看到， TLAB 是一 个 线程 专用 的 内存 分配 区域。

 Java 虚拟 机 就 使用 了 TLAB 这种 线程 专属 的 区域 来 避免 多 线程 冲突， 提高 对象 分配 的 效率。 TLAB 本身 占用 了 eden 区 的 空间。 在 TLAB 启用 的 情况下， 虚拟 机会 为 每一个 Java 线程 分配 一块 TLAB 区域。

 大 对象 无法 在 TLAB 区域 进行 分配， 总是 会 直接 分配 在 堆 上。 由于 TLAB 空间 比较 小， 很容易 装满。 比如， 一个 100KB 的 空间， 如果 已经 使用 了 80KB， 当 需要 再分 配 一个 30KB 的 对象 时， 肯定 就 无能为力 了。 这时， 虚拟 机 有两 种 选择： 第一， 废弃 当前 的 TLAB 区域， 这样 就会 浪费 20KB 空间； 第二， 将 这 30KB 的 对象 直接 分配 在 堆 上， 保留 当前 的 TLAB 区域， 这样 将来 有 小于 20KB 的 对象 分配 请求 时 可以 直接 使用 这块 空间。 当 发生 请求 分配 的 对象 大于 TLAB 内 可用 空间 时， 虚拟 机 如何 在这 两种 行为 中进 行 选择 呢? 虚拟 机 内部 会 维护 一个 叫作 refill_ waste 的 值， 当 请求 对象 大于 refill_ waste 时， 会 选择 在 堆 中 分配， 若 小于 该 值， 则 会 废弃 当前 TLAB 区域， 新建 TLAB 区域 来 分配 新 对象。 这个 阈值 可以 使用 虚拟 机 参数 TLABRefillWasteFraction 来 调整， 它 表示 TLAB 中 允许 产生 这种 浪费 的 比例。 它的 默认值 为 64， 即表示 使用 约为 1/ 64 的 TLAB 区域 作为 refill_ waste。

 默认 情况下， TLAB 和 refill_ waste 的 大小 都是 会在 运行时 不断 调整 的， 使 系统 的 运行 状态 达到 最优。 如果 想 禁用 自动 调整 TLAB 的 大小， 可以 使用- XX:- ResizeTLAB 禁用 ResizeTLAB， 并使 用- XX: TLABSize 手工 指定 TLAB 的 大小。

 如果 想 观察 TLAB 区域 的 使用 情况， 可 打开 跟踪 参数- XX:+ PrintTLAB（ 考虑到 兼容性 问题， JDK9、 JDK10 不再 支持 此 参数）。

### 5.5.6 finalize()函数对垃圾回收的影响

 该 函数 允许 在 子类 中 被 重载， 用于 在 对象 被 回收 时 进行 资源 释放。 目前， 普遍 的 认识 是， 尽量 不要 使用 finalize() 函数 进行 资源 释放， 原因 主要 有 以下 几点：

- 在 使用 finalize（） 函数 时 可能 会 导致 对象 复活。
- finalize（） 函数 的 执行 时间 是 没有 保障 的， 它 完全 由 GC 线程 决定， 在 极端 情况下， 若不 发生 GC， finalize（） 函数 将 没有 机会 执行。
- 一个 糟糕 的 finalize（） 函数 会 严重影响 GC 的 性能。

 finalize() 函数 是由 FinalizerThread 线程 处理 的。 每一个 即将 被 回收 并且 包含 finalize() 函数 的 对象 都会 在 正式 回收 前 加入 FinalizerThread 的 执行 队列， 该 队列 为 java. lang. ref. ReferenceQueue 引用 队列， 内部 实 现为 链 表 结构， 队列 中 每一 项 都为 java. lang. ref. Finalizer 引用， 它 本质 为 一个 引用。

[![img](https://pic.imgdb.cn/item/5f6b414d160a154a67d971aa.jpg)](https://pic.imgdb.cn/item/5f6b414d160a154a67d971aa.jpg)

 虽然 不 推荐 使用 finalize() 函数， 但是 在 有些 场合， 使用 finalize() 函数 可以 起到 双 保险 的 作用。 比如 在 MySQL 的 JDBC 驱动 中， com. mysql. jdbc. ConnectionImpl 就 实现 了 finalize() 函数。

 当 一个 JDBC Connection 被 回收 时， 需要 进行 连接 的 关闭， 即 这里 的 cleanup（） 方法。 事实上， 在 回收 前， 开发 人员 如果 正常 调用 了 Connection. close（） 方法， 连接 就 会被 显 式 关闭， 那样 的 话， 在 cleanup（） 方法 中将 什么 都 不会 做。 而 如果 开发 人员 忘记 显 式 关闭 连接， 而 Connection 对象 又被 回收 了， 则 会 隐式 地 进行 连接 的 关闭， 确保 没有 数据库 连接 泄漏。

## 5.6 温故而知新

#### 1. 与串行回收器相关的参数

- -XX：+ UseSerialGC： 在 新生代 和 老年 代 使用 串行 回收 器。
- -XX： SurvivorRatio： 设置 eden 区 大小 和 survivior 区 大小 的 比例。
- -XX： PretenureSizeThreshold： 设置 大 对象 直接 进入 老 年代 的 阈值。 当 对象 的 大小 超过 这个 值 时， 将 直接 被 分配 在 老 年代。
- -XX： MaxTenuringThreshold： 设置 对象 进入 老 年代 的 年龄 的 最大值。 每一 次 Minor GC 后， 对象 年龄 就 加 1。 任何 大于 这个 年龄 的 对象， 一定 会 进入 老 年代。

#### 2. 与并行GC相关的参数

- -XX：+ UseParNewGC（ 考虑到 兼容性 问题， JDK 9、 JDK 10 已经 删除）： 在 新生代 使用 并行 回收 器。
- -XX：+ UseParallelOldGC： 老年 代 使用 并行 回收 器。
- -XX： ParallelGCThreads： 设置 用于 垃圾 回收 的 线程 数。 通常 情况下 可以 和 CPU 数量 相等， 但在 CPU 数量 比较 多的 情况下， 设置 相对 较小 的 数值 也是 合理 的。
- -XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。 它的 值 是一 个大 于 0 的 整数。 回收 器 在 工作 时， 会 调整 Java 堆 大小 或者 其他 一些 参数， 尽可能 地 把 停顿 时间 控制 在 MaxGCPauseMillis 以内。
- -XX： GCTimeRatio： 设置 吞吐量 大小。 它的 值 是 一个 0 到 100 之间 的 整数。 假设 GCTimeRatio 的 值 为 n， 那么 系统 将 花费 不超过 1/（ 1+ n） 的 时间 用于 垃圾 回收。
- -XX：+ UseAdaptiveSizePolicy： 打开 自 适应 GC 策略。 在这 种 模式 下， 新生代 的 大小、 eden 区 和 survivior 区 的 比例、 晋升 老 年代 的 对象 年龄 等 参数 会被 自动 调整， 以 达到 在 堆 大小、 吞吐量 和 停顿 时间 之间 的 平衡。

#### 3. 与 CMS 回收 器 相关 的 参数（ JDK9、 JDK10 已经 开始 废弃 CMS 回收 器， 建议 使用 G1 回收 器）

- -XX：+ UseConcMarkSweepGC： 新生代 使用 并行 回收 器， 老年 代 使用 CMS+ 串行 回收 器。
- -XX： ParallelCMSThreads： 设定 CMS 的 线程 数量。
- -XX： CMSInitiatingOccupancyFraction： 设置 CMS 回收 器 在 老年 代 空间 被 使用 多少 后 触发， 默认 为 68%。
- -XX：+ UseCMSCompactAtFullCollection： 设置 CMS 回收 器 在 完成 垃圾 回收 后 是否 要 进行 一次 内存 碎片 的 整理。
- -XX： CMSFullGCsBeforeCompaction： 设定 进行 多少 次 CMS 垃圾 回收 后， 进行 一次 内存 压缩。
- -XX：+ CMSClassUnloadingEnabled： 允许 对 类 元 数据区 进行 回收。
- -XX： CMSInitiatingPermOccupancyFraction： 当 永久 区 占用 率 达到 这一 百分比 时， 启动 CMS 回收（ 前提 是 激活 了- XX：+ CMSClassUnloadingEnabled）。
- -XX： UseCMSInitiatingOccupancyOnly： 表示 只在 到达 阈值 的 时候 才 进行 CMS 回收。
- -XX：+ CMSIncrementalMode： 使用 增量 模式， 比较 适合 单 CPU。 增量 模式 在 JDK 8 中 标记 为 废弃， 并且 将 在 JDK 9 中 彻底 移 除。

##### 4. 与 G1 回收 器 相关 的 参数

- -XX：+ UseG1GC： 使用 G1 回收 器。
- -XX： MaxGCPauseMillis： 设置 最大 垃圾 回收 停顿 时间。
- -XX： GCPauseIntervalMillis： 设置 停顿 间隔 时间。

#### 5. TLAB相关

- -XX：+ UseTLAB： 开启 TLAB 分配。
- -XX：+ PrintTLAB（ 考虑到 兼容性 问题， JDK 9、 JDK 10 不再 支持 此 参数）： 打印 TLAB 相关 分配 信息。 ·-XX： TLABSize： 设置 TLAB 区域 大小。
- -XX：+ ResizeTLAB： 自动 调整 TLAB 区域 大小。

#### 6. 其他参数

- -XX：+ DisableExplicitGC： 禁用 显 式 GC。
- -XX：+ ExplicitGCInvokesConcurrent： 使用 并发 方式 处理 显 式 GC。

## 5.7 动手才是真英雄

这章只列标题

### 5.7.1 配置实验环境

### 5.7.2 配置 性能 测试 工具 JMeter

### 5.7.3 配置Web应用服务器Tomcat

### 5.7.4 实战 案例 1— 初试 串行 回收 器

### 5.7.5 实战 案例 2— 扩 大堆 以 提升 系统 性能

### 5.7.6 实战 案例 3— 调整 初始 堆 大小

### 5.7.7 实战 案例 4— 使用 ParrellOldGC 回收 器

### 5.7.8 实战 案例 5— 使用 较小 堆 提高 GC 压力

### 5.7.9 实战 案例 6— 测试 ParallelOldGC 的 表现

### 5.7.10 实战 案例 7— 测试 ParNew 回收 器 的 表现

### 5.7.11 实战 案例 8— 测试 JDK 1. 8 的 表现

### 5.7.12 实战 案例 9— 使用 高 版本 虚拟 机 提升 性能

# 第6章 性能监控工具

## 6.1 有我更高效:Linux下的性能监控工具

### 6.1.1 显示系统整体资源使用情况-top命令。

top 命令 的 输出 可以 分为 两个 部分： 前半部 分 是 统计 信息， 后半部 分 是 进程 信息。

[![img](https://pic.imgdb.cn/item/5f6c85c9160a154a677455d5.jpg)](https://pic.imgdb.cn/item/5f6c85c9160a154a677455d5.jpg)

 在 统计 信息 中， 第 1 行 是 任务 队列 信息， 它的 结果 等 同于 uptime 命令。 从左到右 依次 表示 系统 当前 时间、 系统 运行 时间、 当前 登录 用 户数。 最后 的 load average 表示 系统 的 平均 负载， 即 任务 队列 的 平均 长度， 其中 的 3 个值 分别 表示 1 分钟、 5 分钟、 15 分钟 到 现在 的 平均值。

 第 2 行 是 进程 统计 信息， 分别 是 正在 运行 的 进程 数、 睡眠 进程 数、 停止 的 进程 数、 僵尸 进程 数。

 等 3 行 是 CPU 统计 信息， us 表示 用户 空间 CPU 占用 率、 sy 表示 内核 空间 CPU 占用 率、 ni 表示 用户 进程 空间 改变 过 优先级 的 进程 CPU 的 占用 率、 id 表示 空闲 CPU 占用 率、 wa 表示 等待 输入 和 输出 的 CPU 时间 百分比、 hi 表示 硬件 中断 请求、 si 表示 软件 中断 请求。 在 Mem 中， 从左到右， 依次 表示 物理 内存 总量、 已 使用 的 物理 内存、 空闲 物理 内存、 内核 缓冲 使 用量。 在 Swap 中， 依次 表示 交换 区 总量、 空闲 交换 区 大小、 缓冲 交换 区 大小。

 top 命令 的 第 2 部分 是 进程 信息， 显示 了 系统 内 各个 进程 的 资源 使用 情况， 主要 字段 的 含义 如下。

- PID： 进程 ID。
- USER： 进程 所有者 的 用 户名。
- PR： 优先级。 · NI： nice 值， 负值 表示 高 优先级， 正值 表示 低 优先级。
- %CPU： 上次 更新 到 现在 的 CPU 时间 占用 百分比。
- TIME+： 进程 使用 的 CPU 时间 总计， 单位 为 1/ 100 秒。
- %MEM： 进程 使用 的 物理 内存 百分比。
- VIRT： 进程 使用 的 虚拟 内存 总量， 单位 为 KB， VIRT= SWAP+ RES。
- RES： 进程 使用 的、 未被 换出 的 物理 内存 大小， 单位 为 KB， RES= CODE+ DATA。
- SHR： 共享 内存 大小， 单位 为 KB。
- COMMAND： 命令 名/ 命令行。

注意： 使用 top 命令 可以 从 宏观 上 观察 系统 中 各个 进程 的 CPU 占用 情况， 以及 内存 使用 情况。

### 6.1.2 监控内存和CPU-vmstat命令

 vmstat 命令 也是 一个 功能 比较 齐全 的 性能 监测 工具。 它可 以 统计 CPU、 内存 使用 情况、 Swap 使用 情况 等 信息。 和 sar 工具 类似， vmstat 也可以 指定 采样 周期 和 采样 次数。

[![img](https://pic.imgdb.cn/item/5f6c8684160a154a6774a1e3.jpg)](https://pic.imgdb.cn/item/5f6c8684160a154a6774a1e3.jpg)

[![img](https://pic.imgdb.cn/item/5f6c86c7160a154a6774bc13.jpg)](https://pic.imgdb.cn/item/5f6c86c7160a154a6774bc13.jpg)

### 6.1.3 监控I/O-iostat命令

iostat 命令 可以 提供 详细 的 I/ O 信息， 它的 基本 使用方法 如下：

[![img](https://pic.imgdb.cn/item/5f6c8747160a154a6774ee89.jpg)](https://pic.imgdb.cn/item/5f6c8747160a154a6774ee89.jpg)

以上 命令 显示 了 CPU 的 使用 概况 和 磁盘 I/ O 的 信息。 输出 信息 每 1 秒 采样 1 次， 合计 采样 两次。 如果 只需 要 显示 磁盘 情况， 不需要 显示 CPU 使用 情况， 则 可以 使用 命令：

[![img](https://pic.imgdb.cn/item/5f6c875c160a154a6774f69d.jpg)](https://pic.imgdb.cn/item/5f6c875c160a154a6774f69d.jpg)

如果 需要 得到 更多 的 统计 信息， 可以 使用- x 选项。

### 6.1.4 多功能诊断器——pidstat工具

 pidstat 是一 个 功能 强大 的 性能 监测 工具， 也是 Sysstat 的 组件 之一。 读者 可以 在 http:// www. icewalkers. com/ Linux/ Software/ 59040/ Sysstat. html 下载 这个 工具。 下载 后， 通过./ configure、 make、 make install 等 3 个 命令 即可 安装 pidstat 工具。 如果 是 Ubuntu 系统， 也可以 简单 地 通过 以下 命令 安装：

[![img](https://pic.imgdb.cn/item/5f6c8791160a154a67750dcb.jpg)](https://pic.imgdb.cn/item/5f6c8791160a154a67750dcb.jpg)

#### 1.CPU 使用 率 监控

 pidstat 的 参数- p 用于 指定 进程 ID，- u 表示 对 CPU 使用 率 的 监控。 参数 1 3 表示 每秒 采样 一次， 合计 采样 3 次。 从这 个 输出 中 可以 看到， 该 应用 程序 CPU 占用 率 几乎 达到 100%。 pidstat 的 功能 不仅仅 限于 观察 进程 信息， 还可以 进一步 监控 线程 的 信息。 使用 以下 命令：

[![img](https://pic.imgdb.cn/item/5f6c87cd160a154a677526ab.jpg)](https://pic.imgdb.cn/item/5f6c87cd160a154a677526ab.jpg)

-t 参数 将 系统性 能 的 监控 细化 到 线程 级别。 从这 个 输出 中 可以 知道， 该 Java 应用 程序 之所以 有如 此 高的 CPU 占用 率， 是因为 线程 1204 的 缘故。

#### 2. I/O使用情况监控

 在 程序 运行 过程中， 使用 以下 命令 监控 程序 I/ O 使用 情况。 其中 22796 是 通过 jps 命令 查询 得到 的 进程 ID，- d 参数 表明 监控 对象 为 磁盘 I/ O。 1 3 表示 每秒 采样 一次， 合计 采样 3 次。

[![img](https://pic.imgdb.cn/item/5f6c894a160a154a6776421e.jpg)](https://pic.imgdb.cn/item/5f6c894a160a154a6776421e.jpg)

#### 3.内存监控

下例 使用 pidstat 工具 对 进程 ID 为 27233 的 进程 进行 内存 监控。 每秒 刷新 一次， 共进 行 5 次 统计。

[![img](https://pic.imgdb.cn/item/5f6c8968160a154a67765eff.jpg)](https://pic.imgdb.cn/item/5f6c8968160a154a67765eff.jpg)

## 6.2 用我更高效:Windows下的性能监控工具

### 6.2.1 任务管理器

略

### 6.2.2 perfmon性能监控工具

[![img](https://pic.imgdb.cn/item/5f6c8a74160a154a677720f2.jpg)](https://pic.imgdb.cn/item/5f6c8a74160a154a677720f2.jpg)

### 6.2.3 ProcessExplorer进行管理工具

 ProcessExplorer 是一 款 功能 极其 强大 的 进程 管理 工具。 它 完全可以 替代 Windows 自带 的 任务 管理器。 读者 可以 在 http:// technet. microsoft. com/ en- us/ sysinternals/ bb896653 下载 该 工具。

[![img](https://pic.imgdb.cn/item/5f6c8ad8160a154a67774a5d.jpg)](https://pic.imgdb.cn/item/5f6c8ad8160a154a67774a5d.jpg)

### 6.2.4 pslist工具——Windows下也有命令行工具

读者 可以 在 http:// technet. microsoft. com/ en- us/ sysinternals/ bb896682 下载 并 安装 该 工具。

[![img](https://pic.imgdb.cn/item/5f6c8b10160a154a677764e6.jpg)](https://pic.imgdb.cn/item/5f6c8b10160a154a677764e6.jpg)

## 6.3 外科手术刀: JDK性能监控工具

### 6.3.1 查看Java进程——jps命令

参数- q 可以 指定 jps 只 输出 进程 ID， 而 不 输出 类 的 名称：

参数- m 可以 用于 输出 传递 给 Java 进程（ 主 函数） 的 参数：

参数- l 可以 用于 输出 主 函数 的 完整 路径：

参数- v 可以 显示 传递 给 Java 虚拟 机 的 参数：

注意： jps 命令 类似于 ps 命令， 但 是它 只 列出 系统 中 所有 的 Java 应用 程序。 通过 jps 命令 可以 方便 地 查看 Java 进程 的 启动 类、 传入 参数 和 Java 虚拟 机 参数 等 信息。

### 6.3.2 查看虚拟机运行时信息——jstat命令

[![img](https://pic.imgdb.cn/item/5f6c8c8f160a154a67780c9d.jpg)](https://pic.imgdb.cn/item/5f6c8c8f160a154a67780c9d.jpg)

option 可以 由 以下 值 构成。

- -class： 显示 ClassLoader 的 相关 信息。
- -compiler： 显示 JIT 编译 的 相关 信息。
- -gc： 显示 与 GC 相关 的 堆 信息。
- -gccapacity： 显示 各个 代 的 容量 及 使用 情况。
- -gccause： 显示 垃圾 回收 相关 信息（ 同- gcutil）， 同时 显示 最后 一次 或当 前 正在 发生 的 垃圾 回收 的 诱发 原因。
- -gcnew： 显示 新生代 信息。
- -gcnewcapacity： 显示 新生代 大小 与 使用 情况。
- -gcold： 显示 老 年代 和 永久 代 的 信息。
- -gcoldcapacity： 显示 老 年代 的 大小。
- -gcpermcapacity： 显示 永久 代 的 大小。
- -gcutil： 显示 垃圾 回收 信息。
- -printcompilation： 输出 JIT 编译 的 方法 信息。
- -t 参数 可以 在 输出 信息 前 加上 一个 Timestamp 列， 显示 程序 的 运行 时间。
- -h 参数 可以 指定 在 周期性 数据 输出 时， 输出 多少 行 数据 后 输出 一个 表头 信息。 · interval 参数 用于 指定 输出 统计数据 的 周期， 单位 为 毫秒。
- count 参数 用于 指定 一共 输出 多少 次 数据。

### 6。3.3 查看虚拟机参数——jinfo命令

 jinfo 命令 可以 用来 查看 正在 运行 的 Java 应用 程序 的 扩展 参数， 甚至 支持 在 运行时 修改 部分 参数。

[![img](https://pic.imgdb.cn/item/5f6c8da0160a154a677885b2.jpg)](https://pic.imgdb.cn/item/5f6c8da0160a154a677885b2.jpg)

其中 option 可以 为 以下 信息。

- -flag< name>： 打印 指定 Java 虚拟 机 的 参数 值。
- -flag [+|-]： 设置 指定 Java 虚拟 机 参数 的 布尔 值。
- -flag< name>=< value>： 设置 指定 Java 虚拟 机 参数 的 值。

### 6.3.4 导出堆到文件——jmap命令

 jmap 命令 是 一个 多功能 的 命令。 它可 以 生成 Java 程序 的 堆 Dump 文件， 也可以 查看 堆 内 对象 实例 的 统计 信息、 查看 ClassLoader 的 信息 及 finalizer 队列。

下例 使用 jmap 命令 生成 PID 为 2972 的 Java 程序 的 对象 统计 信息， 并 输出 到 s. txt 文件 中。

[![img](https://pic.imgdb.cn/item/5f6c8e09160a154a6778b7c7.jpg)](https://pic.imgdb.cn/item/5f6c8e09160a154a6778b7c7.jpg)

jmap 命令 另一个 更为重要 的 功能 是 得到 Java 程序 的 当前 堆 快照：

[![img](https://pic.imgdb.cn/item/5f6c8e2a160a154a6778c526.jpg)](https://pic.imgdb.cn/item/5f6c8e2a160a154a6778c526.jpg)

此外， jmap 还可以 查看 系统 的 ClassLoader 的 信息。

[![img](https://pic.imgdb.cn/item/5f6c8e4e160a154a6778d3b3.jpg)](https://pic.imgdb.cn/item/5f6c8e4e160a154a6778d3b3.jpg)

使用 以下 命令 可以 查看 堆积 在 finalizer 队列 中的 对象：

[![img](https://pic.imgdb.cn/item/5f6c8e6f160a154a6778e19d.jpg)](https://pic.imgdb.cn/item/5f6c8e6f160a154a6778e19d.jpg)

### 6.3.5 JDK自带的堆分析工具——jhat命令

使用 jhat 命令 可以 分析 Java 应用 程序 的 堆 快照 内容。

说明： jhat 命令 在 JDK9、 JDK10 中 已经 被 删除， 官方 建议 用 VisualVm 代替， 参考 6. 5. 5 节。

[![img](https://pic.imgdb.cn/item/5f6c8fbc160a154a67797641.jpg)](https://pic.imgdb.cn/item/5f6c8fbc160a154a67797641.jpg)

### 6.3.6 查看线程对堆栈——jstack命令

[![img](https://pic.imgdb.cn/item/5f6c8fde160a154a677987a7.jpg)](https://pic.imgdb.cn/item/5f6c8fde160a154a677987a7.jpg)

-l 选项 用于 打印 锁 的 附加 信息。 jstack 命令 会在 控制台 输出 程序 中 所 有的 锁 信息， 可以 使用 重定向 将 输出 保存 到 文件 中， 如：

[![img](https://pic.imgdb.cn/item/5f6c8ff6160a154a6779934d.jpg)](https://pic.imgdb.cn/item/5f6c8ff6160a154a6779934d.jpg)

注意： 通过 jstack 命令 不仅 可以 得到 线程 堆栈， 还能 自动 进行 死锁 检查， 输出 找到 的 死锁 信息。

### 6.3.7 远程主机信息收集——jstatd命令

 jstatd 命令 是 一个 RMI 服务 端 程序， 它的 作用 相当于 代理 服务器， 建立 本地 计算机 与 远程 监控 工具 的 通信。 jstatd 服务器 将 本机 的 Java 应用 程序 信息 传递 到 远程 计算机。

[![img](https://pic.imgdb.cn/item/5f6c9039160a154a6779b405.jpg)](https://pic.imgdb.cn/item/5f6c9039160a154a6779b405.jpg)

直接 打开 jstatd 服务器 可能 会 抛出 访问 拒绝 异常。这是 由于 jstatd 程序 没有 足够 的 权限 所致。 可以 使用 Java 的 安全 策略， 为 其 分配 相应 的 权限。 下面 的 代码 为 jstatd 分配 了 最大 的 权限， 将其 保存 在 jstatd. all. policy 文件 中：

[![img](https://pic.imgdb.cn/item/5f6c9059160a154a6779c3ba.jpg)](https://pic.imgdb.cn/item/5f6c9059160a154a6779c3ba.jpg)

[![img](https://pic.imgdb.cn/item/5f6c9066160a154a6779c923.jpg)](https://pic.imgdb.cn/item/5f6c9066160a154a6779c923.jpg)

-J 参数 是一 个 公共 的 参数， 如 jps、 jstat 等 命令 都可以 接收 这个 参数。 由于 jps、 jstat 命令 本身 也是 Java 应用 程序，- J 参数 可 以为 jps 等 命令 本身 设置 Java 虚拟 机 参数。

在 默认 情况下， jstatd 命令 将 在 1099 端口 开启 RMI 服务器。

[![img](https://pic.imgdb.cn/item/5f6c9094160a154a6779dd14.jpg)](https://pic.imgdb.cn/item/5f6c9094160a154a6779dd14.jpg)

### 6.3.8 多功能命令行——jcmd命令

 在 JDK 1. 7 以后， 新增 了 一个 命令行 工具 jcmd。 它是 一个 多功能 的 工具， 可以 用来 导出 堆、 查看 Java 进程、 导出 线程 信息、 执行 GC 等。

[![img](https://pic.imgdb.cn/item/5f6c90c4160a154a6779f127.jpg)](https://pic.imgdb.cn/item/5f6c90c4160a154a6779f127.jpg)

（1） 查看 虚拟 机 启动 时间 VM. uptime：

```
jcmd 2828 VM.uptime
```

jcmd 命令 也 支持 直接 使用 MainClass 的 名字 来 代替 进程 号， 这样 在编 写 脚本 的 时候 也 更为 容易。

（2） 打印 线程 栈 信息：

```
jcmd 2828 Thread.print
```

[![img](https://pic.imgdb.cn/item/5f6c913e160a154a677a2d58.jpg)](https://pic.imgdb.cn/item/5f6c913e160a154a677a2d58.jpg)

从 以上 示例 中 可以 看到， jcmd 拥有 jmap 的 大部分 功能， 并且 在 Oracle 的 官方 网 站上 也 推荐 使用 jcmd 命令 代替 jmap 命令。

### 6.3.9 性能统计工具——hprof

hprof 不是 独立 的 监控 工具， 它 只是 一个 Java agent 工具。 它可 以用 于 监控Java 应用 程序 在 运行时 的 CPU 信息 和 堆 信息。 使用 java- agentlib: hprof= help 命令 可以 查看 hprof 的 帮助 文档。

[![img](https://pic.imgdb.cn/item/5f6c9224160a154a677a9675.jpg)](https://pic.imgdb.cn/item/5f6c9224160a154a677a9675.jpg)

### 6.3.10 扩展jps命令

 包括 jps 在内 的 命令 本质上 是 使用 Java 实现 的。 以 jps 命令 为例， 它在 实现 过程中， 使用 MonitoredVmUtil 类 获得 给定 虚拟 机 的 相关 信息。

 其他略

## 6.4 你是我的眼:图形化虚拟机监控工具JConsole

### 6.4.1 Jconsole连接Java程序

JConsole 程序 在% JAVA_ HOME%/ bin 目录 下， 启动 后， 程序 便 要求 指定 连接 Java 应用 程序。

 在 新建 连接 对话框 中， 罗列 了 所有 的 本地 Java 应用 程序， 选择 需要 连接 的 程序 即可。 在 本地 进程 下， 还有 一个 用于 连接 远程 进程 的 文本 框， 输入 正确 的 远程 进程 地址 即可 连接。

如果 需要 使用 JConsole 连接 远程 进程， 则 可以 在 远程 Java 应用 程序 启动 时 加上 如下 参数：

[![img](https://pic.imgdb.cn/item/5f6c9322160a154a677b04fe.jpg)](https://pic.imgdb.cn/item/5f6c9322160a154a677b04fe.jpg)

### 6.4.2 Java程序概况

[![img](https://pic.imgdb.cn/item/5f6c934b160a154a677b16ae.jpg)](https://pic.imgdb.cn/item/5f6c934b160a154a677b16ae.jpg)

### 6.4.3 内存监控

 切换 到 内存 监控 界面， 可以 显示 当前 内存 的 详细信息。 不仅 包括 堆 内存 的 整体 信息， 更 细化 到 eden 区、 survivor 区、 老 年代 的 使用 情况。 同时， 也 包括 非 堆 区， 即 永久 代 的 使用 情况。 单击 右 上角 的“ 执行 GC” 按钮， 可以 强制 应用 程序 进行 一次 Full GC。

[![img](https://pic.imgdb.cn/item/5f6c9427160a154a677b747d.jpg)](https://pic.imgdb.cn/item/5f6c9427160a154a677b747d.jpg)

### 6.4.4 线程监控

 JConsole 中的 线程 选项 卡 允许 开发 人员 监控 程序 内 的 线程， 如图 6. 27 所示。 JConsole 显示 了 系统 内 的 线程 数量， 并在 屏幕 下方 显示 了 程序 中 所有 的 线程。 单击 线程 名称， 便可 以 查看 线程 的 栈 信息。 使用“ 检测

[![img](https://pic.imgdb.cn/item/5f6c946a160a154a677b9196.jpg)](https://pic.imgdb.cn/item/5f6c946a160a154a677b9196.jpg)

### 6.4.5 类加载情况

[![img](https://pic.imgdb.cn/item/5f6c9480160a154a677b9ae8.jpg)](https://pic.imgdb.cn/item/5f6c9480160a154a677b9ae8.jpg)

### 6.4.6 虚拟机信息

在 VM 概要 页， JConsole 显示 了 当前 应用 程序 的 运行 环境， 包括 虚拟 机 类型、 版本、 堆 信息 及 虚拟 机 参数 等。

[![img](https://pic.imgdb.cn/item/5f6c949a160a154a677ba6d8.jpg)](https://pic.imgdb.cn/item/5f6c949a160a154a677ba6d8.jpg)

## 6.5 一目了然: 可视化性能监控工具Visual VM

Visual VM 是一 个 功能 强 大的 多 合一 故障 诊断 和 性能 监控 可 视 化 工具， 它 集成 了 多种 性能 统计 工具 的 功能， 使用 Visual VM 可以 代替 jstat、 jmap、 jhat、 jstack， 甚至 代替 JConsole。 在 JDK6 升级 到 JDK7 以后， Visual VM 便 作为 JDK 的 一部分 发布， 即 它 完全 免费。

 Visual VM 的 一大 特点 是 支持 插件 扩展， 并且 插件 安装 非常 方便。 我们 既可以 通过 离 线下 载 插件 文件*. nbm， 然后 在 Plugin 对话框 的 已 下载 页面 添加 已 下载 的 插件， 也可 以在 可用 插件 页面 下， 在 线 安装 插件。

### 6.5.1 Visual VM连接应用程序

 Visual VM 支持 多种 方式 连接 应用 程序， 最 常用 的 就是 本地 连接。 只要 本地 计算机 内有 Java 应用 程序 正在 执行， 在 Visual VM 的 Local 节点 下， 就会 出现 这些 应用 程序。 双击 应用 程序 或者 使用 鼠标 右键 打开 应用 程序， 就能 够 监控 应用 程序 运行，

[![img](https://pic.imgdb.cn/item/5f6c95cd160a154a677c2942.jpg)](https://pic.imgdb.cn/item/5f6c95cd160a154a677c2942.jpg)

也 支持 远程 JMX 连接。 Java 应用 程序 可以 通过 以下 参数 打开 JMX 端口：

[![img](https://pic.imgdb.cn/item/5f6c95dc160a154a677c3071.jpg)](https://pic.imgdb.cn/item/5f6c95dc160a154a677c3071.jpg)

在 弹出 的 对话框 中 填写 远程 计算机 地址、 端口， 如图 6. 34 所示。 如果 需要 验证， 则 填写 用 户名 和 密码。

[![img](https://pic.imgdb.cn/item/5f6c95f4160a154a677c3a49.jpg)](https://pic.imgdb.cn/item/5f6c95f4160a154a677c3a49.jpg)

### 6.5.2 监控应用程序

[![img](https://pic.imgdb.cn/item/5f6c9612160a154a677c4897.jpg)](https://pic.imgdb.cn/item/5f6c9612160a154a677c4897.jpg)

 单击 Tab 页 面上 的 监视 页面， 即可 监控 应用 程序 CPU、 堆、 永久 区、 类 加载 和 线程 数 的 总体 情况。 通过 页 面上 的“ 执行 垃圾 回收” 和“ 堆 Dump” 按钮 还可以 手工 执行 Full GC 和 生成 堆 快照。

### 6.5.3 Thread Dump和分析

 线程 页面（ 如图 6. 38 所示） 可以 提供 详细 的 线程 信息。 单击 右 上角 的“ 线程 Dump” 按钮 可以 导出 当前 所有 线程 的 堆栈 信息（ 相当于 使用 jstack 命令）。

[![img](https://pic.imgdb.cn/item/5f6c9648160a154a677c5a33.jpg)](https://pic.imgdb.cn/item/5f6c9648160a154a677c5a33.jpg)

注意： Visual VM 的 Thread 页面 提供 了 详细 的 线程 信息， 还会 进行 自动 的 死锁 监测， 一旦 发现 存在 死锁 便会 提示 用户。

### 6.5.4 性能分析

 Visual VM 有两 个 采样 器， 在 Sampler 页面 显示 了 CPU 和 内存 两个 性能 采样 器， 用于 实时 监控 程序 信息。 CPU 采样 器 可以 将 CPU 占用 时间 定位 到 方法， 内存 采样 器 可以 查看 当前 程序 的 堆 信息。

 通过 Visual VM 的 采样 功能， 可以 找到 该 程序 中 占用 CPU 时间 最长 的 方法。

[![img](https://pic.imgdb.cn/item/5f6c9676160a154a677c6a5e.jpg)](https://pic.imgdb.cn/item/5f6c9676160a154a677c6a5e.jpg)

在 Visual VM 的 默认 统计 信息 中， 并不 包含 JDK 的 内置 对象 的 函数 调用 统计， 比如 java.* 包 中的 类。 如果 需要 统计 JDK 内 的 方法 调用 情况， 需要 单击 右 上角 的“ 设置” 选项， 手工 进行 配置。

### 6.5.5 内存快照分析

使用 右键 菜单 中的“ 堆 Dump”， 可以 立即 获得 当前 应用 程序 的 内存 快照。

内存 快照 分析 如图 6. 44 所示， 在 顶部 的 Tab 页 中， 提供 了 4 个 基本功 能 页： 概要、 类、 实例 数 和 OQL 控制台。 下面 分别 介绍 它们。

（1） 概要 页面 展示 了 当前 内存 的 整体 信息， 包括 内存 大小、 实例 总数、 类 总数 等。 （2） 在 类 页面 中， 以 类 为 索引， 显示 了 每个 类 的 实例 数 和 占用 空间。 在 类 页面 中， 还可 以对 两个 不同 的 内存 快照 文件 进行 比较， 这个 功能 可以 帮助 开发者 快速 分析 同一 应用 程序 在 运行 的 不同 时刻， 内存 数据 产生 的 变化。

[![img](https://pic.imgdb.cn/item/5f6c96b5160a154a677c7fef.jpg)](https://pic.imgdb.cn/item/5f6c96b5160a154a677c7fef.jpg)

（3） 在 实例 数 页面 中， 将 显示 指定 类 的 所有 实例。 开发者 可以 查看 当前 内存 中的 实际 内容。 图 6. 46 显示 了 查看 一个 String 对象 实例 页面 的 部分 内容。 可以 看到， 系统 中 所有 的 String 对象 都 一一 被 列出， 并且 可以 看到 所有 对象 的 具体 数据。

（4） OQL 控制台 提供 了 更 强大 的 对象 查询 功能。 有关 Visual VM 的 OQL 支持， 将 在后 续 章节 进行 详细 阐述。

注意： 通过 Visual VM 提供 的 内存 快照 分析 工具， 可以 查看 堆 快照 内 的 类 信息 和 对象 信息。

### 6.5.6 BTrace介绍

 BTrace 是一 款 非常 有意思 的 工具， 它可 以在 不 停机 的 情况下， 通过 字节 码 注入 动态 监控 系统 的 运行 情况， 可以 跟踪 指定 的 方法 调用、 构造 函数 调用 和 系统 内存 等 信息。

 在 Visual VM 中 安装 BTrace 插件 后， 便可 以 针对 Java 应用 程序 执行 BTrace 脚本 了。 在 Java 应用 程序 节点 上 单击 右键， 选择“ Trace application” 即可 进入 BTrace 插件 界面， 如图 6. 48 所示。

[![img](https://pic.imgdb.cn/item/5f6c9755160a154a677cbdb1.jpg)](https://pic.imgdb.cn/item/5f6c9755160a154a677cbdb1.jpg)

其他暂略，参考书即可。

## 6.6 来自JRockit的礼物: 虚拟机诊断工具

Mission Control 程序 为% JAVA_ HOME%/ bin/ jmc. exe， 打开 这 款 软件。

[![img](https://pic.imgdb.cn/item/5f6c9868160a154a677d326f.jpg)](https://pic.imgdb.cn/item/5f6c9868160a154a677d326f.jpg)

### 6.6.1 MBean服务器

 在 Mission Control 界面 左侧 的 JVM 浏览器 中， 枚举 了 系统 内 所有 的 Java 进程。 打开 其中 一个 进程 的 MBean 服务器。

可以 看到， Mission Control 的 界面 非常 有特色， 在 默认 的 界面 中， 以 飞机 仪表 的 视图 显示 了 Java 堆 使用 空间、 CPU 使用 率 和 Live Set+ Fragmentation。

[![img](https://pic.imgdb.cn/item/5f6c9968160a154a677da8b3.jpg)](https://pic.imgdb.cn/item/5f6c9968160a154a677da8b3.jpg)

 单击“ 运行时” 按钮， 如图 6. 55 所示， 通过 左 下侧 的 Tab 页 切换， 还可以 显示 内存、 垃圾 收集、 内存 池、 线程 等 信息。

[![img](https://pic.imgdb.cn/item/5f6c99b0160a154a677dcfee.jpg)](https://pic.imgdb.cn/item/5f6c99b0160a154a677dcfee.jpg)

### 6.6.2 飞行记录器(Flight Recorder)

 飞行 记录器 是 Mission Control 提供 的 另一 大 功能， 和 MBean 服务器 不同， 它 通过 记录 程序 在 一段时间 内 的 运行 情况， 将 记录 结果 进行 分析 和 展示， 可以 更进一步 对 系统 的 性能 进行 分析 和 诊断。 要使 用 飞行 记录器， 要 监控 的 程序 必须 带 以下 参数 启动：

[![img](https://pic.imgdb.cn/item/5f6c99d7160a154a677de40b.jpg)](https://pic.imgdb.cn/item/5f6c99d7160a154a677de40b.jpg)

[![img](https://pic.imgdb.cn/item/5f6c9a07160a154a677e006e.jpg)](https://pic.imgdb.cn/item/5f6c9a07160a154a677e006e.jpg)

# 第7章 分析Java堆

### 7.1.1 堆溢出

 为了 减少 堆 溢出 错误， 一方面 可以 使用- Xmx 参数 指定 一个 更 大的 堆 空间， 另一方面， 由于 堆 空间 不可能 无限 增大， 通过 MAT 或者 Visual VM 等 工具， 找到 大量 占用 堆 空间 的 对象 并在 应用 程序上 做出 合理 的 优化， 也是 十分必要 的。

### 7.1.2 直接内存溢出

 在 Java 的 NIO（ New I/ O） 中， 支持 直接 内存 使用， 也就是 通过 Java 代码 获得 一块 堆 外 的 内存 空间， 这块 空间 是 直接 向 操作系统 申请 的。 直接 内存 的 申请 速度 一般 要比 堆 内存 慢， 但是 其 访问 速度 要 快于 堆 内存。 因此， 对于 那些 可 复 用的， 并且 会被 经常 访问 的 空间， 使用 直接 内存 是 可以 提高 系统性 能 的。 但 由于 直接 内存 没 有被 Java 虚拟 机 完全 托管， 若 使用不当， 也 容易 触发 直接 内存 溢出， 导致 宕 机。

[![img](https://pic.imgdb.cn/item/5f6ed9df160a154a6745d7c7.jpg)](https://pic.imgdb.cn/item/5f6ed9df160a154a6745d7c7.jpg)

 提醒： 如果在此 使 用的 是 JDK 1. 7u40 32 位 Java 虚拟 机， 如果 使用 JDK 1. 7 64 位 虚拟 机， 程序 是 可以 正常 执行 的， 且不 会 出现 OOM， 这是 因为 32 位 计算机 系统 对应 用 程序 的 可用 最大 内存 有限制。 以 Windows 平台 为例， 在 32 位 系统 中， 进程 的 寻址 空间 为 4GB， 其中 2GB 为 用户 空间， 2GB 为 系统 空间， 故 实际 可用 的 系统 内存 只有 2GB， 当 Java 进程 的 所有 内存 之和（ 堆 空间、 栈 空间、 直接 内存 及 虚拟 机 自身 所用 的 内存） 大于 2GB 时， 就会 出现 OOM。

 如果 将上 述 代码 中 第 6 行的 System. gc() 注释 掉， 使 显 式 GC 生效， 那么 程序 将 可以 正常 结束， 这 说明 GC 可以 回收 直接 内存。

 另一个 让 该 程序 正常 执行 的 方法 是 设置 一个 较 小的 堆， 在 不 指定- XX: MaxDirectMemorySize 的 情况下， 最大 可用 直接 内存 等于- Xmx 的 值。

### 7.1.3 过多线程导致OOM

 由于 每一个 线程 的 开启 都要 占用 系统 内存， 因此当 线程 数量 太多 时， 也有 可能 导致 OOM。 由于 线程 的 栈 空间 也 是在 堆 外 分配 的， 因此 和 直接 内存 非常 相似， 如果 想 让 系统 支持 更多 的 线程， 那么 应该 使用 一个 较 小的 堆 空间。

 或者减少 每一个 线程 所占 的 内存 空间， 使用- Xss 参数 可以 指定 线程 的 栈 空间。

 注意： 如果 减小 了 线程 的 栈 空间 大小， 栈 溢出 的 风险 会 相应 地 上升。

### 7.1.4 永久区溢出

 永久 区（ Perm） 是 存放 类 元 数据 的 区域。 如果 一个 系统 中有 太多 的 类型， 那么 永久 区 是有 可能 溢出 的。 在 JDK 1. 8 中， 永久 区 被 一块 称为 元 数据 的 区域 替代， 但是 它们 的 功能 是 类似 的， 都是 为了 保存 类 的 元 信息。

 一般来说要解决永久区问题，可以从以下几个方面考虑:

- 增加MaxPermSize的值
- 减少系统需要的累的数量
- 使用ClassLoader合理地装载各个类，并定期进行回收。

### 7.1.5 GC效率低下引起的OOM

 GC 是 内存 回收 的 关键， 如果 GC 效率 低下， 那么 系统 的 性能 会受 到 严重 的 影响。 如果 系统 的 堆 空间 太小， 那么 GC 所 花的 时间 就会 较多， 并且 回收 所 释放 的 内存 会 较少。 根据 GC 占用 的 系统 时间， 以及 释放 内存 的 大小， 虚拟 机会 评估 GC 的 效率， 一旦 虚拟 机 认为 GC 的 效率 过低， 就有 可能 直接 抛出 OOM。

- 花在 GC 上 的 时间 是否 超过 了 98%。
- 老年 代 释放 的 内存 是否 小于 2%。
- eden 区 释放 的 内存 是否 小于 2%。
- 是否 连续 5 次 GC 都 出现 了 上述 几种 情况（ 注意 是 同时 出现， 不是 出现 一个）。

只有 满足 所有 条件， 虚拟 机 才有 可能 抛出 如下 OOM：

[![img](https://pic.imgdb.cn/item/5f6eee02160a154a674bd9e1.jpg)](https://pic.imgdb.cn/item/5f6eee02160a154a674bd9e1.jpg)

## 7.2 无处不在的字符串:String在虚拟机中的实现

### 7.2.1 String对象的特点

- 不变性
- 针对常量池的优化
- 类的final定义

#### 1.不变性

 一旦生成，则不能对它进行改变。看起来像修改的操作，都是依靠产生新的字符串实现的。

#### 2. 针对常量池的优化

 针对 常量 池 的 优化 指 当 两个 String 对象 拥有 相同 的 值 时， 它们 只 引用 常量 池 中的 同一个 副本。

[![img](https://pic.imgdb.cn/item/5f6eefca160a154a674c682e.jpg)](https://pic.imgdb.cn/item/5f6eefca160a154a674c682e.jpg)

#### 3.类的定义

 除以 上 两点 外， final 类型 定义 也是 String 对象 的 重要 特点。 作为 final 类 的 String 对象 在 系统 中 不可 能有 任何 子类， 这是 对 系统 安全 性的 保护。 同时， 在 JDK 1. 5 版本 之前 的 环境 中， 使用 final 定义 有助于 帮助 虚拟 机 寻找 机会， 内联 所有 的 final 方法， 从而 提高 系统 效率。 但这 种 优化 方法 在 JDK 1. 5 以后， 效果 并不 明显。

### 7.2.2 有关String的内存泄露

 在 JDK 1. 6 中， java. lang. String 主 要由 3 部分 组成： value 数组、 offset 偏移 和 count 长度。

[![img](https://pic.imgdb.cn/item/5f6ef1de160a154a674d2671.jpg)](https://pic.imgdb.cn/item/5f6ef1de160a154a674d2671.jpg)

 这个 结构 为 内存 泄漏 埋下 了 伏笔， 字符串 的 实际 内容 由 value、 offset 和 count 三 者 共同 决定， 而非 value 一项。 试想， 如果 字符串 value 数组 包含 100 个 字符， 而 count 长度 只有 1 个 字节， 那么 这个 String 实际上 只有 1 个 字符， 却占据 了 至少 100 个 字节， 剩余 的 99 个 就 属于 泄漏 的 部分， 它们 不会 被 使用， 不会 被 释放， 却 长期 占用 内存， 直到 字符串 本身 被 回收。

### 7.2.3 有关String常量池的位置

 在 虚拟 机中， 有 一块 称为 常量 池 的 区域 专门 用于 存放 字符串 常量。 在 JDK 1. 6 之前， 这块 区域 属于 永久 区 的 一部分， 但是 在 JDK 1. 7 以后， 它 就被 移 到了 堆 中进 行 管理。

 另外 一点 值得注意 的 是， 虽然 String. intern（） 的 返回 值 永远 等于 字符串 常量。 但这 并不 代表 在 系统 的 每时每刻， 相同 的 字符串 的 intern（） 返回 值 都会 是 一样 的（ 虽然 在 95% 以上 的 情况下， 都是 相同 的）。 因为 存在 这么 一种 可能： 在 一次 intern（） 调用 之后， 该 字符串 在某 一个 时刻 被 回收， 之后， 再进 行 一次 intern（） 调用， 那么 字面 量 相同 的 字符串 重新 被 加入 常量 池， 但是 引用 位置 已经 不同。

## 7.3 虚拟机也有内窥镜：使用MAT分析Java堆

 MAT 是 Memory Analyzer 的 简称， 它 是一 款 功能 强大 的 Java 堆 内存 分析器。 可以 用于 查找 内存 泄漏， 以及 查看 内存 消耗 情况。 MAT 是 基于 Eclipse 开发 的， 是一 款 免费 的 性能 分析 工具。 可以 在 http:// www. eclipse. org/ mat/ 下载 并使 用 MAT。

### 7.3.1 初始MAT

在 分析 堆 快照 前， 首先 需要 导出 应用 程序 的 堆 快照。 在 本书 前文 中 提到 的 jmap、 JConsole 和 Visual VM 等 工具 都可 用于 获得 Java 应用 程序 的 堆 快照 文件。 MAT 本身 也 具有 这个 功能。

 其他略

### 7.3.2 浅堆和深堆

 浅 堆（ Shallow Heap） 和 深 堆（ Retained Heap） 是 两个 非常重 要的 概念， 它们 分别 表示 一个 对象 结构 所占 用的 内存 大小 和 一个 对 象被 GC 回收 后， 可以 真实 释放 的 内存 大小。

 浅 堆（ Shallow Heap） 是指 一个 对象 所 消耗 的 内存。 在 32 位 系统 中， 一个 对象 引用 会 占据 4 字节， 一个 int 类型 变量 会 占据 4 字节， 一个 long 类型 变量 会 占据 8 字节， 每个 对象 头 需要 占用 8 字节。 根据 堆 快照 格式 不同， 对象 的 大小 可能 会 向 8 字节 对齐。 以 String 对象 为例， 如图 7. 13 所示， 显示 了 String 对象 的 几个 属性（ JDK 1. 7， 与 JDK 1. 6 有 差异）。

[![img](https://pic.imgdb.cn/item/5f6ef43f160a154a674e18d4.jpg)](https://pic.imgdb.cn/item/5f6ef43f160a154a674e18d4.jpg)

 深 堆（ Retained Heap） 的 概念 略微 复杂。 要 理解 深 堆， 首先 需要 了解 保留 集（ Retained Set）。 对象 A 的 保留 集 指 当 对象 A 被 回收 后， 可以 被 释放 的 所有 的 对象 集合（ 包括 对象 A 本身）， 即 对象 A 的 保留 集 可以 被认为 是 只能 通过 对象 A 被 直接 或 间接 访 问到 的 所有 对象 的 集合。 通俗 地说， 就 是指 仅 被 对象 A 所持 有的 对象 的 集合。 深 堆 是指 对象 的 保留 集中 所有 的 对象 的 浅 堆 大小 之和。

注意： 浅 堆 指 对象 本身 占用 的 内存， 不包括 其内 部 引用 对象 的 大小。 一个 对象 的 深 堆 指 只能 通过 该 对象 访 问到 的（ 直接 或 间接） 所有 对象 的 浅 堆 之和， 即对 象被 回收 后， 可以 释放 的 真实 空间。

### 7.3.3 MAT堆分析案例解析

略

### 7.3.4 支配树(Domainator Tree)

 MAT 提供 了 一个 称为 支配 树（ Dominator Tree） 的 对象 图。 支配 树 体现 了 对象 实例 间的 支配 关系。 在 对象 引用 图中， 所有 指向 对象 B 的 路径 都 经过 对象 A， 则 认为 对象 A 支配 对象 B。 如果 对象 A 是 离 对象 B 最近 的 一个 支配 对象， 则 认为 对象 A 为 对象 B 的 直接 支配者。 支配 树 是 基于 对象 间的 引用 图 所 建立 的， 它有 以下 基本 性质：

- 对象 A 的 子 树（ 所有 被 对象 A 支配 的 对象 集合） 表示 对象 A 的 保留 集（ Retained Set）， 即 深 堆。 ·
- 如果 对象 A 支配 对象 B， 那么 对象 A 的 直接 支配者 也 支配 对象 B。 ·
- 支配 树 的 边 与 对象 引 用图 的 边 不 直接 对应。

### 7.3.5 Tomcat堆溢出分析

略

## 7.4 筛选对对象:MAT对OQL的支持

### 7.4.1 SELECT子句

 在 MAT 中， Select 子句 的 格式 与 SQL 基本 一致， 用于 指定 要 显示 的 列。 Select 子句 中 可以 使用“*”， 查看 结果 对象 的 引用 实例（ 相当于 outgoing references）。

### 7.4.2 FROM子句

From 子句 用于 指定 查询 范围， 它可 以 指定 类 名、 正 则 表达式 或者 对象 地址。

### 7.4.3 Where子句

Where 子句 用于 指定 OQL 的 查询 条件。 OQL 查询 将 只 返回 满足 Where 子句 指定 条件 的 对象。 Where 子句 的 格式 与 传统 SQL 极为 相似。

### 7.4.4 内置对象与方法

OQL 中 可以 访问 堆 内 对象 的 属性， 也可以 访问 堆 内 代理 对象 的 属性。 访问 堆 内 对象 的 属性 时， 格式 如下：

[![img](https://pic.imgdb.cn/item/5f6ef5cf160a154a674e85bc.jpg)](https://pic.imgdb.cn/item/5f6ef5cf160a154a674e85bc.jpg)

## 7.5 更精彩的查找: Visual VM对OQL的支持

### 7.5.1 Visual VM的OQL的基本语法

[![img](https://pic.imgdb.cn/item/5f6ef60e160a154a674e9814.jpg)](https://pic.imgdb.cn/item/5f6ef60e160a154a674e9814.jpg)

 注意： 对于 MAT 来说， OQL 的 关键字， 如 select、 from 等 可以 使用 大写， 也可以 使用 小写， 但 对于 Visual VM 而言， 必须 统一 使用 小写。

 select 子句 和 where 子句 支持 使用 JavaScript 语法 处理 较 复杂 的 查询 逻辑， select 子句 可以 使用 类似 JSON 的 语法 输出 多个 列。 from 子句 可以 使用 instanceof 关键字， 将 给定 类 的 子类 也 包括 到 输出 列表 中。

### 7.5.2 内置heap对象

[![img](https://pic.imgdb.cn/item/5f6ef65c160a154a674eafa6.jpg)](https://pic.imgdb.cn/item/5f6ef65c160a154a674eafa6.jpg)

### 7.5.3 对象函数

 在 Visual VM 中， 还为 OQL 语言 提供 了 一组 以 对象 为 操作 目标 的 内置 函数。 通过 这些 函数， 可以 获取 目标 对象 的 更多 信息。

#### 1.classof() 函数

#### 2.objectid()函数

#### 3.reachables()函数

#### 4.referrers()函数

#### 5.referees()函数

#### 6.sizeof()函数

#### 7.rsizeof()函数

#### 8.toHtml()函数

### 7.5.4 集合/统计函数

Visual VM 中 还有 一组 用于 集合 操作 和 统计 的 函数。 可以 方便 地 对 结果 集 进行 处理 或者 统计 操作。 集合/ 统计 函数 主要 有 contains()、 count()、 filter()、 length()、 map()、 max()、 min()、 sort()、 top()、 sum()、 unique() 等。

### 7.5.5 程序化OSQL分析Tomcat堆

 Visual VM 不仅 支持 在 OQL 控制 台上 执行 OQL， 也可以 通过 其 OQL 相关 的 JAR 包， 将 OQL 查询 程序 化， 从而 获得 更加 灵活 的 对象 查询 功能， 实现 堆 快照 分析 的 自动化。

# 第8章 锁与并发

知识点：

- 理解 线程 安全 的 重要性。
- “锁” 在 虚拟 机内 的 基本 实现 方式。
- 应用 层 对“ 锁” 进行 优化 的 一般 方法 和 思路。
- 无 锁 计算 的 方法 和 原理。
- 理解 Java 虚拟 机内 存 模型。

## 8.1 安全就是锁存在的理由: 锁的基本概念和实现

 通过 锁 可以 让 多个 线程 排队 一个 一个 地 进入 临界 区 访问 目标 对象， 使 目标 对象 的 状态 总 保持一致， 这也 就是 锁 存在 的 价值。

### 8.1.1 理解线程安全

 通过 锁 可以 实现 线程 安全， 线程 安全 就 是在 多 线程 环境 下， 无论 多个 线程 如何 访问 目标 对象， 目标 对象 的 状态 应该 始终 是 保持一致 的， 线程 的 行为 也 总是 正确 的。

[![img](https://pic.imgdb.cn/item/5f6ef90b160a154a674f5f4e.jpg)](https://pic.imgdb.cn/item/5f6ef90b160a154a674f5f4e.jpg)

### 8.1.2 对象头和锁

 在 Java 虚拟 机 的 实现 中 每个 对象 都有 一个 对 象头， 用于 保存 对象 的 系统 信息。 对象 头中 有一个 称为 Mark Word 的 部分， 它是 实现 锁 的 关键。 在 32 位 系统 中， Mark Word 为 一个 32 位 的 数据， 在 64 位 系统 中， 它 占 64 位。 它是 一个 多功能 的 数据区， 可以 存放 对象 的 哈 希 值、 对象 年龄、 锁 的 指针 等 信息。 一个 对象 是否 占用 锁、 占用 哪个 锁， 就 记录 在 这个 Mark Word 中。

[![img](https://pic.imgdb.cn/item/5f6ef93c160a154a674f6bf9.jpg)](https://pic.imgdb.cn/item/5f6ef93c160a154a674f6bf9.jpg)

 它 表示 Mark Word 中有 25 位（ 比特） 表示 对象 的 哈 希 值， 4 位 表示 对象 的 年龄， 1 位 表示 是否 为 偏向 锁， 2 位 表示 锁 的 信息。

[![img](https://pic.imgdb.cn/item/5f6ef975160a154a674f7aee.jpg)](https://pic.imgdb.cn/item/5f6ef975160a154a674f7aee.jpg)

## 8.2 避免残酷的竞争: 锁在Java虚拟机中的实现与优化

### 8.2.1 偏向锁

 偏向 锁 是 JDK 1. 6 提出 的 一种 锁 优化 方式。 其 核心 思想 是， 如果 程序 没有 竞争， 则 取消 之前 已经 取得 锁 的 线程 同步 操作。 也 就说， 某一 锁 被 线程 获取 后， 就会 进入 偏向 模式， 当 线程 再次 请求 这个 锁 时， 无须 再进 行 相关 的 同步 操作， 从而 节省 了 操作 时间。在 JVM 中 使用- XX:+ UseBiasedLocking 可以 设置 启用 偏向 锁。

[![img](https://pic.imgdb.cn/item/5f6ef9e3160a154a674f960a.jpg)](https://pic.imgdb.cn/item/5f6ef9e3160a154a674f960a.jpg)

 偏向 锁 在 锁 竞争 激烈 的 场合 没有 太强 的 优化 效果， 因为 大量 的 竞争 会 导致 持有 锁 的 线程 不停 地 切换， 锁 也 很难 一直 保持 在 偏向 模式， 此时 使用 锁 偏向 不仅 得不到 性能 优化， 反而 有可能 降低 系统 性能。 因此， 在 竞争 激烈 的 场合， 可以 尝试 使用- XX:- UseBiasedLocking 参数 禁用 偏向 锁。

### 8.2.2 轻量级锁

 如果 偏向 锁 失败， Java 虚拟 机会 让 线程 申请 轻量级 锁。 轻量级 锁 在 虚拟 机内 部 使用 一个 称为 BasicObjectLock 的 对象 实现， 这个 对象 内部 由 一个 BasicLock 对象 和 一个 持有 该 锁 的 Java 对象 指针 组成。 BasicObjectLock 对象 放置 在 Java 栈 的 栈 帧 中。 在 BasicLock 对象 内部 还 维护 着 displaced_ header 字段， 它 用于 备份 对象 头部 的 Mark Word。

[![img](https://pic.imgdb.cn/item/5f6efafc160a154a674fe351.jpg)](https://pic.imgdb.cn/item/5f6efafc160a154a674fe351.jpg)

 BasicLock 通过 set_ displaced_ header() 方法 备份 了 原 对象 的 Mark Word。 接着， 使用 CAS 操作， 尝试 将 BasicLock 的 地址 复制 到 对 象头 的 Mark Word。 如果 复制 成功， 那么 加锁 成功， 否则 认为 加锁 失败。 如果 加锁 失败， 那么 轻量级 锁 就有 可能 膨胀 为重 量级 锁。

[![img](https://pic.imgdb.cn/item/5f6efb18160a154a674feac6.jpg)](https://pic.imgdb.cn/item/5f6efb18160a154a674feac6.jpg)

### 8.2.3 锁膨胀

 当 轻量级 锁 失败， 虚拟 机 就会 使用 重量级 锁。 在 使用 重量级 锁 时， 对象 的 Mark Word 如下：

[![img](https://pic.imgdb.cn/item/5f6efb69160a154a674ffd46.jpg)](https://pic.imgdb.cn/item/5f6efb69160a154a674ffd46.jpg)

 第 1 步 是 废弃 前面 BasicLock 备份 的 对象 头 信息。 第 2 步 则 正式 启用 重量级 锁。 启用 过程 分为 两步： 首先 通过 inflate() 方法 进行 锁 膨胀， 其 目的 是 获得 对象 的 ObjectMonitor； 然后 使用 enter() 方法 尝试 进入 该 锁。 在 调用 enter() 方法 时， 线程 很可能 会在 操作系统 层面 被 挂起， 此时 线程 间 切换 和 调度 的 成本 就会 比 较高。

### 8.2.4 自旋锁

 锁 膨胀 后， 进入 ObjectMonitor 的 enter() 方法， 线程 很可能 会在 操作系统 层面 被 挂起， 这样 线程 上下文 切换 的 性能 损失 就比 较大。 在 锁 膨胀 之后， 虚拟 机会 做 最后 的 争取， 希望 线程 可以 尽快 进入 临界 区 而 避免 被 操作系统 挂起。 一种 较为 有效 的 手段 就是 使用 自 旋 锁。

 自 旋 锁 可以 使 线程 在 没有 取得 锁 时不 被 挂起， 而去 执行 一个 空 循环（ 即 所谓 的 自 旋）， 在 若干个 空 循环 后， 线程 如果 可以 获得 锁， 则 继续 执行。 若 线程 依然 不能 获得 锁， 才会 被 挂起。 使用 自 旋 锁 后， 线程 被 挂起 的 概率 相对 减小， 线程 执行 的 连贯性 相对 加强。 因此， 对于 那些 锁 竞争 不是 很 激烈、 锁 占用 时间 很短 的 并发 线程， 具有 一定 的 积极 意义， 但 对于 锁 竞争 激烈、 单 线程 锁 占用 时间 长的 并发 程序， 自 旋 锁 在 自 旋 等待 后， 往往 依然 无法 获得 对应 的 锁， 不仅 白白 浪费 了 CPU 时间， 最终 还是 免不了 被 挂起， 浪费 了 系统 资源。

 在 JDK 1. 6 中， Java 虚拟 机 提供- XX:+ UseSpinning 参数 来 开启 自 旋 锁， 使用- XX: PreBlockSpin 参数 来 设置 自 旋 锁 的 等待 次数。

 在 JDK 1. 7 后的 版本， 自 旋 锁 的 参数 被 取消， 虚拟 机 不再 支持 由 用户 配置 自 旋 锁。 自 旋 锁 总是 被 执行， 自 旋 次数 也由 虚拟 机 自行 调整。

### 8.2.5 锁消除

 锁 消除 是 Java 虚拟 机 在 JIT 编译 时， 通过 对 运行 上下文 的 扫描， 去除 不可能 存在 共享 资源 竞争 的 锁。 通过 锁 消除， 可以 节省 毫无意义 的 请求 锁 时间。

 虚拟 机 可以 在 运行时， 基于 逃逸 分析 技术， 捕获 这些 不可能 存在 竞争 却有 申请 锁 的 代码 段， 并 消除 这些 不必要 的 锁， 从而 提高 系统 性能。

 逃逸 分析 和 锁 消除 分别 可以 使用 参数- XX:+ DoEscapeAnalysis 和- XX:+ EliminateLocks 开启（ 锁 消除 必须 工作 在- server 模式 下）。

## 8.3 应对残酷的竞争: 锁在应用层的优化思路

### 8.3.1 减少锁持有时间

注意： 减少 锁 的 持有 时间 有助于 减小 锁 冲突 的 可能性， 进而 提升 系统 的 并发 能力。

### 8.3.2 减少锁粒度

 减小 锁 粒度 也是 一种 削弱 多 线程 锁 竞争 的 有效 手段。 这种 技术 典型的 使用 场景 就是 ConcurrentHashMap 类 的 实现。

 减少 锁 粒度 会 引入 一个 新的 问题： 当 系统 需要 取得 全局 锁 时， 消耗 的 资源 会 比较 多。

注意： 所谓 减少 锁 粒度， 就是 指 缩小 锁定 对象 的 范围， 从而 减小 锁 冲突 的 可能性， 进而 提高 系统 的 并发 能力。

### 8.3.3 锁分离

 锁 分离 是 减小 锁 粒度 的 一个 特例， 它 依据 应用 程序 的 功能 特点， 将 一个 独占 锁 分成 多个 锁。 一个 典型的 案例 就是 java. util. concurrent. LinkedBlockingQueue 的 实现。

### 8.3.4 锁粗化

 在 通常 情况下， 为了 保证 多 线程 的 有效 并发， 会要 求 每个 线程 持有 锁 的 时间 尽量 短， 即在 使用 完 公共 资源 后， 应该 立即 释放 锁。 只有 这样， 等待 这个 锁 的 其他 线程 才能 尽早 地 获得 资源 执行任务。 但是， 凡事 都有 一个 度， 如果 对 同一个 锁 不停 地 进行 请求、 同步 和 释放， 本身 也会 消耗 系统 宝贵 的 资源， 反而 不利于 性能 优化。

 为此， 虚拟 机 在 遇到 一连串 连续 地 对 同一 锁 不断 进行 请求 和 释放 的 操作 时， 便会 把 所 有的 锁 操作 整合 成对 锁 的 一次 请求， 从而 减少 对 锁 的 请求 同步 次数， 这个 操作 叫作 锁 粗 化。

[![img](https://pic.imgdb.cn/item/5f6eff6a160a154a67511272.jpg)](https://pic.imgdb.cn/item/5f6eff6a160a154a67511272.jpg)

 注意： 性能 优化 就是 根据 运行时 的 真实 情况 对 各个 资源 点 进行 权衡 的 过程。 锁 粗 化 的 思想 和 减少 锁 持有 时间 是 相反 的， 在 不同 的 场合 它们 的 效果 不同， 开发 人员 需要 根据 实际情况 进行 权衡。 此外， 前文 提到 的 偏向 锁、 自 旋 锁 作为 虚拟 机 内部 的 锁 优化 策略， 也不 是 绝对 可以 提高 系统 性能， 对 锁 的 优化 还是 需要 做 更多 的 权衡 和 思考。

## 8.4 无招胜有招: 无锁

 在高并发时，对锁的激烈竞争可能会成为系统瓶颈，为此，开发人员可以使用一种成为非阻塞同步的方法，不需要使用锁，所以也称为无锁。

### 8.4.1 理解CAS

 最简单的非阻塞同步为ThreadLocal，每个线程拥有各自独立的变量副本，无须相互等待。

 本节将介绍一种更为重要的、基于CAS算法的无锁控制方法。

 无锁算法的设计和实现都比锁复杂得多，但是对死锁问题天生免疫，而且拥有更加优越的性能。

 CAS的过程是这样的: 包含3个参数，形式是CAS(V,E,N)。V表示要更新的变量,E表示预期值,N表示新值。仅当V的值等于E的值时，才会将V的值更新为N，否则说明已经有其他线程做了更新，则当前线程什么都不做。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然也允许放弃。

 JDK1.6以后，虚拟机可以使用这个指令来实现并发操作和并发数据结构

[![img](https://pic.imgdb.cn/item/5f6f0173160a154a6751a7b1.jpg)](https://pic.imgdb.cn/item/5f6f0173160a154a6751a7b1.jpg)

### 8.4.2 原子操作

 JDK的java.util.concurrent.atomic包下,有一组使用无锁算法实现的原子操作类。

 以AtomicInteger为例，核心方法有：

[![img](https://pic.imgdb.cn/item/5f6f01c2160a154a6751d4f3.jpg)](https://pic.imgdb.cn/item/5f6f01c2160a154a6751d4f3.jpg)

### 8.4.3 新宠儿LongAddr

 JDK1.8引入了LongAddr类，性能更上一层楼。

 AtomicInteger等原子类的实现，都在一个死循环内，不断尝试修改目标值，知道修改成功。如果竞争不激烈，修改成功概率就很高。如果大量修改失败时，会影响性能。

 结合前文介绍的减少锁粒度，有一种改进思路。一种方案是仿造ConcurrentHashMap，将热点数据分离。LongAdder就使用了这种思想。

[![img](https://pic.imgdb.cn/item/5f6f026e160a154a67520dd3.jpg)](https://pic.imgdb.cn/item/5f6f026e160a154a67520dd3.jpg)



## 8.5 将随机变为可控: 理解Java内存模型

 Java内存模型(JMM)就是用来解释多线程数据访问的一致性，将这种看似随机的状态变为可控，从而屏蔽多线程可能引发的种种问题。

### 8.5.1 原子性

 原子性的原子代表不可分割的意思。

### 8.5.2 有序性

 在指令执行时，可能会对目标指令进行重排，对于当前线程自己看是有序的，但是一个线程观察另外一个线程时，可能会乱序。

[![img](https://pic.imgdb.cn/item/5f6f039a160a154a67526e07.jpg)](https://pic.imgdb.cn/item/5f6f039a160a154a67526e07.jpg)

### 8.5.3 可见性

 可见性是指当一个线程修改一个变量的值时，在另外一个线程中可以马上得知这个修改。由于系统编译器优化，部分变量的值可能会被寄存器或高速缓冲缓存，而每个CPU都拥有独立的寄存器和Cache，从而导致其他线程无法发现这个修改。

### 8.5.4 Happens-Befor原则

 指令重排有原则，以下是一些基本原则:

[![img](https://pic.imgdb.cn/item/5f6f0476160a154a6752b65a.jpg)](https://pic.imgdb.cn/item/5f6f0476160a154a6752b65a.jpg)

# 第9章 Class文件结构

知识点：

- Class文件的基本结构
- 使用jClassLib查看Class文件
- 使用ASM手工生成Class文件

## 9.1 不仅跨平台，还能跨语言: 语言无关性

[![img](https://pic.imgdb.cn/item/5f709101160a154a67c8bd7a.jpg)](https://pic.imgdb.cn/item/5f709101160a154a67c8bd7a.jpg)

## 9.2 虚拟机的基石:Class文件

[![img](https://pic.imgdb.cn/item/5f70911d160a154a67c8c9bc.jpg)](https://pic.imgdb.cn/item/5f70911d160a154a67c8c9bc.jpg)



 在Java虚拟机规范中， Class文件使用一种类似于C语言结构体的方式进行描述，并且同意使用无符号整数为基本类型，由u1、u2、u4、u8分别表示无符号单字节、2字节、4字节和8字节整数。对于字符串，则使用u1数组进行表示。

[![img](https://pic.imgdb.cn/item/5f7091da160a154a67c91f6f.jpg)](https://pic.imgdb.cn/item/5f7091da160a154a67c91f6f.jpg)

(1) 文字以一个4字节的Magic(被称为魔数)老太皮，紧跟大、小版本号

(2) 在版本号之后是常量池, 常量池的个数为constant_pool_count, 常量池中的表项有constant_pool_count-1项，

(3) 常量池之后是类的访问修饰符、代表自身类的引用、父类引用及接口数量和实现的接口引用。

(4) 在接口之后，有字段的数量和字段描述、方法数量及方法的描述。

(5) 存放类文件的属性信息。

### 9.2.1 Class文件的标志——魔数

 魔数作为Class文件的标志，用来告诉Java虚拟机，这是一个Class文件。固定为0xCAFEBABE。

### 9.2.2 Class文件的版本

 魔数后面，紧跟Class的小版本号和大版本号。首先是小版本号，2字节无符号整数，之后是大版本号，也是2字节。

[![img](https://pic.imgdb.cn/item/5f709386160a154a67c9bad4.jpg)](https://pic.imgdb.cn/item/5f709386160a154a67c9bad4.jpg)

 目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。

### 9.2.3 存放所有常数——常量池

 在版本号之后，紧跟的是常量池的数量以及若干个常量池表项。

 在详细解析常量池之之前，先给出常量池表项类型及TAG值。

[![img](https://pic.imgdb.cn/item/5f709417160a154a67c9ef46.jpg)](https://pic.imgdb.cn/item/5f709417160a154a67c9ef46.jpg)

[![img](https://pic.imgdb.cn/item/5f709576160a154a67ca6cc0.jpg)](https://pic.imgdb.cn/item/5f709576160a154a67ca6cc0.jpg)

 UTF8常量经常被其他类型的常量引用。

[![img](https://pic.imgdb.cn/item/5f7095ab160a154a67ca831c.jpg)](https://pic.imgdb.cn/item/5f7095ab160a154a67ca831c.jpg)

 其中tag为7，name_index表示常量池的索引，该索引指向的常量必须是CONSTANT_Utf8

[![img](https://pic.imgdb.cn/item/5f709665160a154a67cad823.jpg)](https://pic.imgdb.cn/item/5f709665160a154a67cad823.jpg)

[![img](https://pic.imgdb.cn/item/5f7096b8160a154a67cafad9.jpg)](https://pic.imgdb.cn/item/5f7096b8160a154a67cafad9.jpg)

[![img](https://pic.imgdb.cn/item/5f70972e160a154a67cb322c.jpg)](https://pic.imgdb.cn/item/5f70972e160a154a67cb322c.jpg)

类的方法和字段分别用CONSTANT_Methodref和CONSTANT_Fieldref表示。

[![img](https://pic.imgdb.cn/item/5f709757160a154a67cb4595.jpg)](https://pic.imgdb.cn/item/5f709757160a154a67cb4595.jpg)

其他暂略

### 9.2.4 CLass的访问标记(Access Flag)

[![img](https://pic.imgdb.cn/item/5f70987b160a154a67cbc7b3.jpg)](https://pic.imgdb.cn/item/5f70987b160a154a67cbc7b3.jpg)

### 9.2.5 当前类、父类和接口

 在访问标记后，会指定该类的类别、父类类别及实现的接口。

[![img](https://pic.imgdb.cn/item/5f709965160a154a67cc37d7.jpg)](https://pic.imgdb.cn/item/5f709965160a154a67cc37d7.jpg)

### 9.2.6 Class文件的字段

 由于一个类有多个字段，所以需要首先指明字段的个数。

[![img](https://pic.imgdb.cn/item/5f709a68160a154a67ccb0ee.jpg)](https://pic.imgdb.cn/item/5f709a68160a154a67ccb0ee.jpg)

(1) 字段的访问标记，非常类似于类的访问标记。

[![img](https://pic.imgdb.cn/item/5f709a86160a154a67ccc1e1.jpg)](https://pic.imgdb.cn/item/5f709a86160a154a67ccc1e1.jpg)

(2) 一个2字节整数，表示字段的名称，它指向常量池中的CONSTANT_Utf8结构

(3) 名称后的descriptor_index也指向Utf8，用于描述字段的类型。

(4) 一个字段可能还拥有一些属性，用于存储更多的额外信息，比如初始值、一些注释信息等。

[![img](https://pic.imgdb.cn/item/5f709c3a160a154a67cda807.jpg)](https://pic.imgdb.cn/item/5f709c3a160a154a67cda807.jpg)

### 9.2.7 Class文件的方法基本结构

[![img](https://pic.imgdb.cn/item/5f709c80160a154a67cdc902.jpg)](https://pic.imgdb.cn/item/5f709c80160a154a67cdc902.jpg)

### 9.2.8 方法的执行主体——Code属性

[![img](https://pic.imgdb.cn/item/5f709cc3160a154a67cde87c.jpg)](https://pic.imgdb.cn/item/5f709cc3160a154a67cde87c.jpg)

### 9.2.9 记录行号——LineNumberTable属性

[![img](https://pic.imgdb.cn/item/5f709d16160a154a67ce1dd2.jpg)](https://pic.imgdb.cn/item/5f709d16160a154a67ce1dd2.jpg)

### 9.2.10 保存局部变量和参数——LocalVariableTable属性

 局部变量表。

[![img](https://pic.imgdb.cn/item/5f709d38160a154a67ce2fd9.jpg)](https://pic.imgdb.cn/item/5f709d38160a154a67ce2fd9.jpg)

### 9.2.11 加快字节码校验——StackMapTable属性

[![img](https://pic.imgdb.cn/item/5f709d9d160a154a67ce65ac.jpg)](https://pic.imgdb.cn/item/5f709d9d160a154a67ce65ac.jpg)

### 9.2.12 Code属性总结

[![img](https://pic.imgdb.cn/item/5f709e26160a154a67cea364.jpg)](https://pic.imgdb.cn/item/5f709e26160a154a67cea364.jpg)

### 9.2.13 抛出异常——Exceptions属性

[![img](https://pic.imgdb.cn/item/5f709e5b160a154a67ceb932.jpg)](https://pic.imgdb.cn/item/5f709e5b160a154a67ceb932.jpg)

### 9.2.14 用实例分析Class的方法结构

略

### 9.2.15 我来自哪里——SourceFile属性

[![img](https://pic.imgdb.cn/item/5f709ea2160a154a67ced659.jpg)](https://pic.imgdb.cn/item/5f709ea2160a154a67ced659.jpg)

### 9.2.16 强大的动态调用——BootstrapMethods属性

 为了支持JDK1.7中的invokeDynamic指令，增加了BootstrapMethods属性。

[![img](https://pic.imgdb.cn/item/5f709eed160a154a67cef4a5.jpg)](https://pic.imgdb.cn/item/5f709eed160a154a67cef4a5.jpg)

### 9.2.17 内部类——InnerClasses属性

[![img](https://pic.imgdb.cn/item/5f709f33160a154a67cf18bb.jpg)](https://pic.imgdb.cn/item/5f709f33160a154a67cf18bb.jpg)

### 9.2.18 将要废弃的通知——Deprecated属性

[![img](https://pic.imgdb.cn/item/5f709f53160a154a67cf2501.jpg)](https://pic.imgdb.cn/item/5f709f53160a154a67cf2501.jpg)

## 9.3 操作字节码：走进ASM

### 9.3.1 ASM体系结构

 以ASM5.0作为基础进行讲解。

[![img](https://pic.imgdb.cn/item/5f709faf160a154a67cf537a.jpg)](https://pic.imgdb.cn/item/5f709faf160a154a67cf537a.jpg)

略

### 9.3.2 ASM之Hello World

略

# 第10章 Class装载系统

知识点：

- Class文件的加载过程。
- ClassLoader的工作模式。
- 有关类的热加载

## 10.1 来去都有序: 看懂Class文件的装载过程

 Class通常以文件形式存在，只有被Java虚拟机装载的Class类型才能在程序中使用。系统装载Class可以分为加载、连接和初始化3步。连接又可分为验证、准备和解析3步。

[![img](https://pic.imgdb.cn/item/5f71d354160a154a672bcd00.jpg)](https://pic.imgdb.cn/item/5f71d354160a154a672bcd00.jpg)

### 10.1.1 类装载的条件

 Class文件只有在必须要使用的时候才会被装载，不会无条件装载Class。一个类或接口在初次使用前，必须进行初始化。主动使用只有下列几种情况：

[![img](https://pic.imgdb.cn/item/5f71d3b3160a154a672be445.jpg)](https://pic.imgdb.cn/item/5f71d3b3160a154a672be445.jpg)

 如果使用-XX:+TraceClassLoading参数，可以跟踪类加载。

 在使用一个字段时，只有直接定义该字段的类才会被初始化。

 final常量不会引起类初始化。

 javac在编译时，将常量直接植入目标类，不再使用被引用类。

 注意：并不是在代码中出现的类就一定会被加载或初始化。

### 10.1.2 加载类

 加载类是第一个阶段，在该阶段，必须完成以下工作：

- 通过类的全面获取类的二进制数据流。
- 解析类的二进制数据流为方法区的数据结构。
- 创建java.lang.Class类的实例，表示该类型。

### 10.1.3 验证类

 开始连接操作，第一步是验证，目的是保证加载的字节码是合法、合理并且规范的。验证的步骤比较复杂，实际要验证的项目很繁多。虚拟机要做的检查如图

[![img](https://pic.imgdb.cn/item/5f71d837160a154a672d0fc2.jpg)](https://pic.imgdb.cn/item/5f71d837160a154a672d0fc2.jpg)

(1) 必须判断类的二进制数据是否符合格式要求和规范，比如魔数、主版本和肖版本号，数据中的每一项的长度的正确性，等等。

(2) 语义检查，父类是否存在，final方法或类是否被重载或继承了，非抽象类是否实现了所有抽象方法或接口方法，是佛存在不兼容的方法。

(3) 字节码验证

(4) 进行符号引用验证。Class文件在常量池会通过字符串记录自己将要使用的其他类或方法，会验证这些类或方法是否存在，以及是否有权限访问。如果无法找到，就会抛出NoClassDefFoundError。

### 10.1.4 准备

 在这个阶段，会为类分配响应的内存空间，并设置初始值。

[![img](https://pic.imgdb.cn/item/5f71d99d160a154a672d64c3.jpg)](https://pic.imgdb.cn/item/5f71d99d160a154a672d64c3.jpg)

 如果类存在常量字段，那么常量字段也会在准备阶段被赋予上正确的值，这个赋值属于Java虚拟机行为，属于变量初始化。但是，在准备阶段不会有任何代码被执行。

 如果没有final修饰，此时constString的复制在函数`<client>`中发生，属于Java字节码的行为。

 注意：ldc字节码会加载一个常量到操作数栈中，putstatic字节码设置给定的静态字段的值。

### 10.1.5 解析类

 解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。

 符号引用就是一些字面量的引用，和虚拟机的内部数据结构与内存布局无关。

 所谓的解析就是将符号引用转换为直接引用，也就是得到类或者字段、方法在内存中的指针或偏移量。

### 10.1.6 初始化

 初始化阶段的重要工作就是执行类的初始化方法`<client>`。由编译器自动生成，是类静态成员复制语句以及static块共同产生。

 虚拟机会在内部确保其多线程环境中的安全性。只有一个线程可以进入`<client>`方法。带锁安全，可能出现死锁，很难发现，而且没有可用的锁信息。

[![img](https://pic.imgdb.cn/item/5f71dd60160a154a672e9ed2.jpg)](https://pic.imgdb.cn/item/5f71dd60160a154a672e9ed2.jpg)

## 10.2 一切Class从这里开始: 掌握Classloader

 它主要工作在Class装载的加载阶段，主要作用是从系统外部获得Class二进制流。

### 10.2.1 认识ClassLoader，看懂类加载

 只能印象类的加载。

[![img](https://pic.imgdb.cn/item/5f71ddcb160a154a672ec4ec.jpg)](https://pic.imgdb.cn/item/5f71ddcb160a154a672ec4ec.jpg)

### 10.2.2 ClassLoader的分类。

 在标准Java程序中，会创建3类ClassLoader为整个应用程序服务。

- BootStrap ClassLoader: 启动类加载器。
- Extension ClassLoader: 扩展类加载器。
- App ClassLoader: 应用类加载器。

每一个应用程序还可以拥有自定义的ClassLoader，以扩展Java虚拟机获取Class数据的能力。

[![img](https://pic.imgdb.cn/item/5f71de71160a154a672f0456.jpg)](https://pic.imgdb.cn/item/5f71de71160a154a672f0456.jpg)

 判断类是否已经被加载时，会从底层类加载器来时判断，需要加载类会从顶层类开始加载。

 任何在启动类中加载的类是无法获取其ClassLoader实例，因为它是一个系统级的纯C语言的实现。

### 10.2.3 ClassLoader的双亲委派模式

 在类加载时，会判断类是否已经被加载，如果已经被加载，就会直接返回可用类，否则会尝试加载。在加载时，会先请求双亲处理。

[![img](https://pic.imgdb.cn/item/5f71e091160a154a672fa450.jpg)](https://pic.imgdb.cn/item/5f71e091160a154a672fa450.jpg)

提示：双亲为null有连中华情况：第一，双亲就是启动类加载器，第二，当前就是启动类加载器。

[![img](https://pic.imgdb.cn/item/5f71e10e160a154a672fc848.jpg)](https://pic.imgdb.cn/item/5f71e10e160a154a672fc848.jpg)

-Xbootclasspath参数可以修改启动ClassPath。

### 10.2.4 双亲委派模式的弊端

 检查类是否已经加载的委托过程是单向的，但是会带来一个问题，上层的ClassLoader无法访问下层ClassLoader所加载的类。

### 10.2.5 双亲委派模式的补充

 通常把狠心类(rt.jar)中提供外部服务、可由应用层自行实现的接口称为Service Provider Interface，即SPI。

[![img](https://pic.imgdb.cn/item/5f71e2bf160a154a67302c7f.jpg)](https://pic.imgdb.cn/item/5f71e2bf160a154a67302c7f.jpg)

[![img](https://pic.imgdb.cn/item/5f71e2ce160a154a67303010.jpg)](https://pic.imgdb.cn/item/5f71e2ce160a154a67303010.jpg)

### 10.2.6 突破双亲模式

 双亲模式是默认行为，但是并非必须这么做，通过重载ClassLoader可以修改该行为。

### 10.2.7 热替换的实现

 Java并非天生就支持热替换，实现这个功能的一个可行的方法就是灵活运用ClassLoader。

[![img](https://pic.imgdb.cn/item/5f71e458160a154a6730a6c9.jpg)](https://pic.imgdb.cn/item/5f71e458160a154a6730a6c9.jpg)

[![img](https://pic.imgdb.cn/item/5f71e492160a154a6730b668.jpg)](https://pic.imgdb.cn/item/5f71e492160a154a6730b668.jpg)

# 第11章 字节码执行

知识点：

- 使用javap查看Class文件信息。
- 了解字节码执行过程。
- 熟悉常用字节码。
- 学习JIT相关参数配置。
- 通过ASM增强方法的功能。
- 使用Java Agent动态修改字节码。

## 11.1 代码如何执行：字节码执行案例

[![img](https://pic.imgdb.cn/item/5f71e88b160a154a6731f85a.jpg)](https://pic.imgdb.cn/item/5f71e88b160a154a6731f85a.jpg)

[![img](https://pic.imgdb.cn/item/5f71e899160a154a6731fc90.jpg)](https://pic.imgdb.cn/item/5f71e899160a154a6731fc90.jpg)

 calc()方法里面显示了栈大小、局部变量表大小、字节码指令、行号、局部变量表。

## 11.2 执行的基础: Java虚拟机常用指令介绍

### 11.2.1 常量入栈指令

 const系列指令用于特定的常量入栈，入栈的常量隐含在指令本身。

[![img](https://pic.imgdb.cn/item/5f71e9af160a154a67325139.jpg)](https://pic.imgdb.cn/item/5f71e9af160a154a67325139.jpg)

### 11.2.2 局部变量压栈指令

[![img](https://pic.imgdb.cn/item/5f71e9cc160a154a6732587e.jpg)](https://pic.imgdb.cn/item/5f71e9cc160a154a6732587e.jpg)

### 11.2.3 出栈装入局部变量表指令

 主要以store形式存在，比如xstore(x为i、l、f、d、a)、xstore_n(x为i、l、f、d、a，n为0到3)和xstore(x为i、l、f、d、a、b、c、s)。

### 11.2.4 通用型操作

 通用性操作提供了无须指明数据类型的操作。

 指令NOP是一个非常特殊指令，字节码位0x00，表示什么都不做。用于调试、占位等。

 还有两个比较重要的dup和pop，前者是复制，复制栈顶元素并压栈。pop则是把一个元素从栈顶弹出，并直接废弃。

 注意：pop指令只能丢弃一个字节长，如果要丢弃栈顶64位数据，则需要pop2，同理还有dup2指令。

### 11.2.5 类型转换指令

[![img](https://pic.imgdb.cn/item/5f71ec6b160a154a67334faa.jpg)](https://pic.imgdb.cn/item/5f71ec6b160a154a67334faa.jpg)

### 11.2.6 运算指令

[![img](https://pic.imgdb.cn/item/5f71ec94160a154a67336000.jpg)](https://pic.imgdb.cn/item/5f71ec94160a154a67336000.jpg)

### 11.2.7 对象操作指令

#### 1.创建指令

 主要有new, newarrray, anewarray和multianewarray。

#### 2. 字段访问指令

 主要有getfield, putfield, getstatic, putstatic

#### 3. 类型检查指令

 主要有checkcast和instanceof。

#### 4. 数组操作指令

 主要有xastore和xload。

### 11.2.8 比较控制指令

#### 1.比较指令

 有dcmpg, fcmpg, fcmpl, lcmp。

#### 2. 条件跳转指令

 有ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnotnull。

#### 3. 比较跳转指令

 比较指令和条件跳转指令的结合体。

 有if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpge, if_acmpeq和if_acmpne.

 如果条件成立则跳转。

#### 4. 多分支跳转指令

 专门为swtich-case准备，主要有tableswitch和lookupswitch。

[![img](https://pic.imgdb.cn/item/5f71eea6160a154a673404f1.jpg)](https://pic.imgdb.cn/item/5f71eea6160a154a673404f1.jpg)

[![img](https://pic.imgdb.cn/item/5f71eeb7160a154a673408cf.jpg)](https://pic.imgdb.cn/item/5f71eeb7160a154a673408cf.jpg)

#### 5.无条件跳转指令

 主要是goto。指令jsr、ret虽然也是无条件跳转，但是主要用于try-finally语句，而且逐渐被废弃。

 goto接收两个字节的操作数，goto_w接收4个字节操作数，可以表示更大的地址范围。

### 11.2.9 函数调用与返回指令

 支持函数调用与返回值处理，提供了：

- invokevirtual
- invokeinterface
- invokespecial
- invokestatic
- invokedynamic

### 11.2.10 同步控制

 为了实现多线程同步，提供了monitorenter、moniterexit来完成临界区的进入和离开操作。

 进入同步块时，当前对象的监视器数为0则准许进入，若为1，则判断持有当前监视器的线程是否是自己，如果是，则进入，否则进行等待，直到对象的监视器技术为0，才会允许进入同步块。虚拟机中，任何对象都有一个监视器与之关联，用来判断对象是否被锁定，监视器被持有后，对象处于锁定状态。

### 11.2.11 再看Class的方法结构

 略

## 11.3 更上一层楼：再看ASM

### 11.3.1 为类增加安全控制

略

### 11.3.2 统计函数执行时间

略

## 11.4 谁说Java太刻板: Java Agent运行时修改类

### 11.4.1 使用-javaagent参数启动虚拟机

可以指定一个jar包，对该jar包有如下要求：

(1) 这个jar包的MANIFEST.MF文件必须指定Premain-Class项。

(2)Premain-Class指定哪个类必须实现premain()方法。

[![img](https://pic.imgdb.cn/item/5f71f493160a154a6735ca01.jpg)](https://pic.imgdb.cn/item/5f71f493160a154a6735ca01.jpg)

### 11.4.2 使用Java Agent为函数增加计时功能

略

### 11.4.3 动态重转换类

略

### 11.4.4 有关Java Agent的总结

略

## 11.5 与时俱进：动态方法调用

这章没看明白

### 11.5.1 方法句柄使用实例

略。

### 11.5.2 调用点使用实例

略

### 11.5.3 反射和方法句柄

略

### 11.5.4 指令invokedynamic

略

## 11.6 跑得再快点：静态编译优化

略

## 11.7 提高虚拟机的执行效率:JIT及其相关参数

略