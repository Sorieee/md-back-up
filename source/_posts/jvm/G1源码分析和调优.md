# 1. 垃圾回收概述

## 1.2　本书常见术语

**并行（parallelism）**，指两个或者多个事件在同一时刻发生，在现代计算机中通常指多台处理器上同时处理多个任务。

**并行（parallelism）**，指两个或者多个事件在同一时刻发生，在现代计算机中通常指多台处理器上同时处理多个任务。



**JVM中的并行**，指多个垃圾回收相关线程在操作系统之上并发运行，这里的并行强调的是只有垃圾回收线程工作，Java应用程序都暂停执行，因此ParNew工作的时候一定发生了STW。本书提到的***ParTask（例如G1ParTask）指的就是在这些任务运行的时候应用程序都必须暂停。



**JVM中的并发**，指垃圾回收相关的线程并发运行（如果启动多个线程），同时这些线程会和Java应用程序并发运行。本书提到的***Concurrent***Thread（例如ConcurrentG1RefineThread）就是指这些线程和Java应用程序同时运行。

**Stop-the-world（STW）**，直译就是停止一切，在JVM中指停止一切Java应用线程。

**安全点（Safepoint）**，指JVM在执行一些操作的时需要STW，但并不是任何线程在任何地方都能进入STW，例如我们正在执行一段代码时，线程如何能够停止？设计安全点的目的是，当线程进入到安全点时，线程就会主动停止。

**Mutator**，在很多英文文献和JVM源码中，经常看到这个单词，它指的是我们的Java应用线程。Mutator的含义是可变的，在这里的含义是因为线程运行，导致了内存的变化。GC中通常需要STW才能使Mutator暂停。

**记忆集（Remember Set）**，简称为RSet。主要记录不同代际对象的引用关系。

**Refine**，尚未有统一的翻译，有时翻译为细化，但是不太准确，本书中不做翻译。G1中的ConcurrentG1RefineThread主要指处理RSet的线程。

**Evacuation**，转移、撤退或者回收，简称为Evac，本书中不做翻译。在G1中指的是发现活跃对象，并将对象复制到新地址的过程。

**回收（Reclaim）**，通常指的是分区对象已经死亡或者已经完成Evac，分区可以被JVM再次使用。

**Closure**，闭包，本书中不做翻译。在JVM中是一种辅助类，类似于我们已知的iterator，它通常提供了对内存的访问。

**GC Root**，垃圾回收的根。在JVM的垃圾回收过程中，需要从GC Root出发标记活跃对象，确保正在使用的对象在垃圾回收后都是存活的。****

**根集合（Root Set）**。在JVM的垃圾回收过程中，需要从不同的GC Root出发，这些GC Root有线程栈、monitor列表、JNI对象等，而这些GCRoot就构成了Root Set。

**Full GC**，简称为FGC，整个堆的垃圾回收动作。通常Full GC是串行的，G1的Full GC不仅有串行实现，在JDK10中还有并行实现。

**再标记（Remark）**。在本书中指的是并发标记算法中，处理完并发标记后，需要更新并发标记中Mutator变更的引用，这一步需要STW。

## 1.3　回收算法概述

**引用计数法**：在堆内存中分配对象时，会为对象分配一段额外的空间，这个空间用于维护一个计数器，如果对象增加了一个新的引用，则将增加计数器。如果一个引用关系失效则减少计数器。当一个对象的计数器变为0，则说明该对象已经被废弃，处于不活跃状态，可以被回收。引用计数法需要解决循环依赖的问题，在我们众所周知的Python语言里，垃圾回收就使用了引用计数法。

**可达性分析法（根引用分析法）**，基本思路就是将根集合作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象没有被任何引用链访问到时，则证明此对象是不活跃的，可以被回收。

* 垃圾回收算法实现主要分为复制（Copy）、标记清除（Mark-Sweep）和标记压缩（Mark-Compact）。
* 在回收方法上又可以分为串行回收、并行回收、并发回收。
* ·在内存管理上可以分为代管理和非代管理。

### 1.3.1 分代管理算法

​	其思想来源是：有些对象存活的时间短，有些对象存活的时间长，把存活时间短的对象放在一个区域管理，把存活时间长的对象放在另一个区域管理。

​	我们假定内存被划分成2个代：新生代和老生代。把容易死亡的对象放在新生代，通常采用复制算法回收；把预期存活时间较长的对象放在老生代，通常采用标记清除算法。

### 1.3.2　复制算法

​	复制算法的实现也有很多种，可以使用两个分区，也可以使用多个分区。使用两个分区时内存的利用率只有50%；使用多个分区（如3个分区），则可以提高内存的使用率。我们这里演示把堆空间分为1个新生代（分为3个分区：Eden、Survivor0、Survivor1）、1个老生代的收集过程。

​	普通对象创建的时候都是放在Eden区，S0和S1分别是两个存活区。第一次垃圾收集前S0和S1都为空，在垃圾收集后，Eden和S0里面的活跃对象（即可以通过根集合到达的对象）都放入了S1区，如图1-1所示。

![](https://pic.imgdb.cn/item/627224bc0947543129c8d94d.jpg)

回收后Mutator继续运行并产生垃圾，在第二次运行前Eden和S1都有活跃对象，在垃圾收集后，Eden和S1里面的活跃对象（即可以通过根节点到达的对象）都被放入到S0区，一直这样循环收集，如图1-2所示。

![](https://pic.imgdb.cn/item/627224dd0947543129c92754.jpg)

### 1.3.3　标记清除

​	从根集合出发，遍历对象，把活跃对象入栈，并依次处理。处理方式可以是广度优先搜索也可以是深度优先搜索（通常使用深度优先搜索，节约内存）。标记出活跃对象之后，就可以把不活跃对象清除。下面演示一个简单的例子，从根集合出发查找堆空间的活跃对象，如图1-3所示。

![](https://pic.imgdb.cn/item/627225140947543129c9aa8c.jpg)

​	这里仅仅演示了如何找到对象，没有进一步介绍找到对象后如何处理。对于标记清除算法其实还需要额外的数据结构（比如一个链表）来记录可用空间，在对象分配的时候从这个链表中寻找能够容纳对象的空间。当然这里还有很多细节都未涉及，比如在分配时如何找到最合适的内存空间，有FirstFit、Best Fit和Worst Fit等方法，这里不再赘述。标记清除算法最大的缺点就是使内存碎片化。

### 1.3.4　标记压缩

​	标记压缩算法是为了解决标记清除算法中使内存碎片化的问题，除了上述的标记动作之外，还会把活跃对象重新整理从头开始排列，减少内存碎片。

### 1.3.5　算法小结

![](https://pic.imgdb.cn/item/627225b80947543129cb5197.jpg)

## 1.4　JVM垃圾回收器概述

### 1.4.1　串行回收

​	串行回收使用单线程进行垃圾回收，在回收的时候Mutator需要STW。新生代通常采用复制算法，老生代通常采用标记压缩算法。串行回收典型的线程交互图如图1-4所示。

![](https://pic.imgdb.cn/item/627226070947543129cc1792.jpg)

### 1.4.2　并行回收

​	并行回收使用多线程进行垃圾回收，在回收的时候Mutator需要暂停，新生代通常采用复制算法，老生代通常采用标记压缩算法。线程交互如图1-5所示。

![](https://pic.imgdb.cn/item/627226480947543129ccc3b3.jpg)

### 1.4.3 并发标记回收

​	并发标记回收（CMS）的整个回收期间划分成多个阶段：初始标记、并发标记、重新标记、并发清除等。在初始标记和重新标记阶段需要暂停Mutator，在并发标记和并发清除期间可以和Mutator并发运行，如图1-6所示。这个算法通常适用于老生代，新生代可以采用并行回收。

![](https://pic.imgdb.cn/item/6272266d0947543129cd1ba4.jpg)

### 1.4.4　垃圾优先回收

​	垃圾优先回收器（Garbage-First，也称为G1）从JDK7 Update 4开始正式提供。G1致力于在多CPU和大内存服务器上对垃圾回收提供软实时目标和高吞吐量。G1垃圾回收器的设计和前面提到的3种回收器都不一样，它在并行、串行以及CMS GC针对堆空间的管理方式上都是连续的，如图1-7所示。

![](https://pic.imgdb.cn/item/627226a00947543129cd861b.jpg)

​	连续的内存将导致垃圾回收时收集时间过长，停顿时间不可控。因此G1将堆拆成一系列的分区（Heap Region），这样在一个时间段内，大部分的垃圾收集操作只针对一部分分区，而不是整个堆或整个（老生）代，如图1-8所示。

![](https://pic.imgdb.cn/item/627226b30947543129cdb73a.jpg)

​	在G1里，新生代就是一系列的内存分区，这意味着不用再要求新生代是一个连续的内存块。类似地，老生代也是由一系列的分区组成。这样也就不需要在JVM运行时考虑哪些分区是老生代，哪些是新生代。事实上，G1通常的运行状态是：映射G1分区的虚拟内存随着时间的推移在不同的代之间切换。例如一个G1分区最初被指定为新生代，经过一次新生代的回收之后，会将整个新生代分区都划入未使用的分区中，那它可以作为新生代分区使用，也可以作为老生代分区使用。很可能在完成一个新生代收集之后，一个新生代的分区在未来的某个时刻可用于老生代分区。同样，在一个老生代分区完成收集之后，它就成为了可用分区，在未来某个时候可作为一个新生代分区来使用。

​	G1新生代的收集方式是并行收集，采用复制算法。与其他JVM垃圾回收器一样，一旦发生一次新生代回收，整个新生代都会被回收，这也就是我们常说的新生代回收（Young GC）。但是G1和其他垃圾回收器不同的地方在于：

* G1会根据预测时间动态改变新生代的大小。

> 其他垃圾回收新生代的大小也可以动态变化，但这个变化主要是根据内存的使用情况进行的。G1中则是以预测时间为导向，根据内存的使用情况调整新生代分区的数目。

* G1老生代的垃圾回收方式与其他JVM垃圾回收器对老生代处理有着极大的不同。G1老生代的收集不会为了释放老生代的空间对整个老生代做回收。相反，在任意时刻只有一部分老生代分区会被回收，并且，这部分老生代分区将在下一次增量回收时与所有的新生代分区一起被收集。这就是我们所说的混合回收（Mixed GC）。在选择老生代分区的时候，优先考虑垃圾多的分区，这也正是垃圾优先这个名字的由来。后续我们将逐一介绍这些内容。



​	在G1中还有一个概念就是大对象，指的是待分配的对象大小超过一定的阈值之后，为了减少这种对象在垃圾回收过程的复制时间，直接把对象分配到老生代分区中而不是新生代分区中。

从实现角度来看，G1算法是复合算法，吸收了以下算法的优势：

* 列车算法，对内存进行分区，参见图1-8。
* CMS，对分区进行并发标记。
* 最老优先，最老的数据（通常也是垃圾）优先收集。



关于列车算法、CMS和最老优先可以参考其他的书籍，这里不再赘述。

https://blog.csdn.net/weixin_34269583/article/details/89897448

https://www.zhihu.com/question/52213790

# 2. G1的概念

## 2.1　分区

​	分区（Heap Region，HR）或称堆分区，是G1堆和操作系统交互的最小管理单位。G1的分区类型（HeapRegionType）大致可以分为四类：

* 自由分区（Free Heap Region，FHR）
* 新生代分区（Young Heap Region，YHR）
* 大对象分区（Humongous Heap Region，HHR）
* 老生代分区（Old Heap Region，OHR）



​	其中新生代分区又可以分为Eden和Survivor；大对象分区又可以分为：大对象头分区和大对象连续分区。

​	每一个分区都对应一个分区类型，在代码中常见的is_young、is_old、is_houmongous等判断分区类型的函数都是基于上述的分区类型实现，关于分区类型代码如下所示：

![](https://pic.imgdb.cn/item/62722d4d0947543129dd3e94.jpg)

​	HR的大小直接影响分配和垃圾回收效率。如果过大，一个HR可以存放多个对象，分配效率高，但是回收的时候花费时间过长；如果太小则导致分配效率低下。为了达到分配效率和清理效率的平衡，HR有一个上限值和下限值，目前上限是32MB，下限是1MB（为了适应更小的内存分配，下限可能会被修改，在目前的版本中HR的大小只能为1MB、2MB、4MB、8MB、16MB和32MB），默认情况下，整个堆空间分为2048个HR（该值可以自动根据最小的堆分区大小计算得出）。HR大小可由以下方式确定：

* 可以通过参数G1HeapRegionSize来指定大小，这个参数的默认值为0。
* 启发式推断，即在不指定HR大小的时候，由G1启发式地推断HR大小。



HR启发式推断根据堆空间的最大值和最小值以及HR个数进行推断，设置Initial HeapSize（默认为0）等价于设置Xms，设置MaxHeapSize（默认为96MB）等价于设置Xmx。堆分区默认大小的计算方式在HeapRegion.cpp中的setup_heap_region_size()，代码如下所示：

![](https://pic.imgdb.cn/item/62722e8f0947543129e03462.jpg)

![](https://pic.imgdb.cn/item/62722e9f0947543129e0521d.jpg)

​	按照默认值计算，G1可以管理的最大内存为2048×32MB=64GB。假设设置xms=32G，xmx=128G，则每个堆分区的大小为32M，分区个数动态变化范围从1024到4096个。

​	G1中大对象不使用新生代空间，直接进入老生代，那么多大的对象能称为大对象？简单来说是region_size的一半。

**新生代大小**

​	新生代大小指的是新生代内存空间的大小，前面提到G1中新生代大小按分区组织，即首先计算整个新生代的大小，然后根据上一节中的计算方法计算得到分区大小，两者相除得到需要多少个分区。G1中与新生代大小相关的参数设置和其他GC算法类似，G1中还增加了两个参数G1MaxNewSizePercent和G1NewSizePercent用于控制新生代的大小，整体逻辑如下：

* 如果设置新生代最大值（MaxNewSize）和最小值（NewSize），可以根据这些值计算新生代包含的最大的分区和最小的分区；注意Xmn等价于设置了MaxNewSize和NewSize，且NewSize=MaxNewSize。
* 如果既设置了最大值或者最小值，又设置了NewRatio，则忽略NewRatio。
* 如果没有设置新生代最大值和最小值，但是设置了NewRatio，则新生代的最大值和最小值是相同的，都是整个堆空间/（NewRatio+1）。
* 如果没有设置新生代最大值和最小值，或者只设置了最大值和最小值中的一个，那么G1将根据参数G1MaxNewSizePercent（默认值为60）和G1NewSizePercent（默认值为5）占整个堆空间的比例来计算最大值和最小值。

## 2.2　G1停顿预测模型

​	G1是一个响应时间优先的GC算法，用户可以设定整个GC过程的期望停顿时间，由参数MaxGCPauseMillis控制，默认值200ms。不过它不是硬性条件，只是期望值，G1会努力在这个目标停顿时间内完成垃圾回收的工作，但是它不能保证，即也可能完不成（比如我们设置了太小的停顿时间，新生代太大等）。

**衰减平均（Decaying Average）**是一种简单的数学方法，用来计算一个数列的平均值，核心是给近期的数据更高的权重，即强调近期数据对结果的影响。衰减平均计算公式如下所示：

![](https://pic.imgdb.cn/item/6272306c0947543129e49d11.jpg)

​	式中α为历史数据权值，1-α为最近一次数据权值。即α越小，最新的数据对结果影响越大，最近一次的数据对结果影响最大。不难看出，其实传统的平均就是α取值为(n-1)/n的情况。

同理，衰减方差的定义如下：

![](https://pic.imgdb.cn/item/627230950947543129e4eee5.jpg)

在这个预测计算公式中：

* davg表示衰减均值。
* sigma()返回一个系数，来自G1ConfidencePercent（默认值为50，sigma为0.5）的配置，表示信赖度。
* dsd表示衰减标准偏差。
* confidence_factor表示可信度相关系数，confidence_factor当样本数据不足时（小于5个）取一个大于1的值，并且样本数据越少该值越大。当样本数据大于5时confidence_factor取值为1。这是为了弥补样本数据不足，起到补偿作用。

* 方法的参数TruncateSeq，顾名思义，是一个截断的序列，它只跟踪序列中最新的n个元素。在G1GC过程中，每个可测量的步骤花费的时间都会记录到TruncateSeq（继承了AbsSeq）中，用来计算衰减均值、衰减变量、衰减标准偏差等，代码如下所示：

![](https://pic.imgdb.cn/item/627230f40947543129e5c1de.jpg)

​	这个add方法就是上面两个衰减公式的实现代码。其中_davg为衰减均值，_dvariance为衰减方差，_alpha默认值为0.7。G1的软实时停顿就是通过这样的预测模型来实现的。

## 2.3 卡表和位图

​	卡表（CardTable）在CMS中是最常见的概念之一，G1中不仅保留了这个概念，还引入了RSet。卡表到底是一个什么东西？

​	GC最早引入卡表的目的是为了对内存的引用关系做标记，从而根据引用关系快速遍历活跃对象。举个简单的例子，有两个分区，假设分区大小都为1MB，分别为A和B。如果A中有一个对象objA，B中有一个对象objB，且objA.field=objB，那么这两个分区就有引用关系了，但是如果我们想找到分区A，要如何引用分区B？做法有两种：

* 遍历整个分区A，一个字一个字的移动（为什么以字为单位？原因是JVM中对象会对齐，所以不需要按字节移动），然后查看内存里面的值到底是不是指向B，这种方法效率太低，可以优化为一个对象一个对象地移动（这里涉及JVM如何识别对象，以及如何区分指针和立即数），但效率还是太低。

* 借助额外的数据结构描述这种引用关系，例如使用类似位图（bitmap）的方法，记录A和B的内存块之间的引用关系，用一个位来描述一个字，假设在32位机器上（一个字为32位），需要32KB（32KB×32=1M）的空间来描述一个分区。那么我们就可以在这个对象ObjA所在分区A里面添加一个额外的指针，这个指针指向另外一个分区B的位图，如果我们可以把对象ObjA和指针关系进行映射，那么当访问ObjA的时候，顺便访问这个额外的指针，从这个指针指向的位图就能找到被ObjA引用的分区B对应的内存块。通常我们只需要判定位图里面对应的位是否有1，有的话则认为发生了引用。



​	以位为粒度的位图能准确描述每一个字的引用关系，但是一个位通常包含的信息太少，只能描述2个状态：引用还是未引用。实际应用中JVM在垃圾回收的时候需要更多的状态，如果增加至一个字节来描述状态，则位图需要256KB的空间，这个数字太大，开销占了25%。所以一个可能的做法位图不再描述一个字，而是一个区域，JVM选择512字节为单位，即用一个字节描述512字节的引用关系。选择一个区域除了空间利用率的问题之外，实际上还有现实的意义。我们知道Java对象实际上不是一个字能描述的（有一个参数可以控制对象最小对齐的大小，默认是8字节，实际上Java在JVM中还有一些附加信息，所以对齐后最小的Java对象是16字节），很多Java对象可能是几十个字节或者几百个字节，所以用一个字节描述一个区域是有意义的。但是我没有找到512的来源，为什么512效果最好？没有相应的数据来支持这个数字，而且这个值不可以配置，不能修改，但是有理由相信512字节的区域是为了节约内存额外开销。按照这个值，1MB的内存只需要2KB的额外空间就能描述引用关系。这又带来另一个问题，就是512字节里面的内存可能被引用多次，所以这是一个粗略的关系描述，那么在使用的时候需要遍历这512字节。

​	再举一个例子，假设有两个对象B、C都在这512字节的区域内。为了方便处理，记录对象引用关系的时候，都使用对象的起始位置，然后用这个地址和512对齐，因此B和C对象的卡表指针都指向这一个卡表的位置。那么对于引用处理也有可有两种处理方法：

* 处理的时候会以堆分区为处理单位，遍历整个堆分区，在遍历的时候，每次都会以对象大小为步长，结合卡表，如果该卡表中对应的位置被设置，则说明对象和其他分区的对象发生了引用。具体内容在后文中介绍Refine的时候还会详细介绍。
* 处理的时候借助于额外的数据结构，找到真正对象的位置，而不需要从头开始遍历。在后文的并发标记处理时就使用了这种方法，用于找到第一个对象的起始位置。



​	在G1除了512字节粒度的卡表之外，还有bitMap，例如使用bitMap可以描述一个分区对另外一个分区的引用情况。在JVM中bitMap使用非常多，例如还可以描述内存的分配情况。

​	G1在混合收集算法中用到了并发标记。在并发标记的时候使用了bitMap来描述对象的分配情况。例如1MB的分区可以用16KB（16KB×ObjectAlignmentInBytes×8=1MB）来描述，即16KB额外的空间。其中ObjectAlignmentInBytes是8字节，指的是对象对齐，第二个8是指一个字节有8位。即每一个位可以描述64位。例如一个对象长度对齐之后为24字节，理论上它占用3个位来描述这个24字节已被使用了，实际上并不需要，在标记的时候只需要标记这3个位中的第一个位，再结合堆分区对象的大小信息就能准确找出。其最主要的目的是为了效率，标记一个位和标记3个位相比能节约不少时间，如果对象很大，则更划算。这些都是源码的实现细节，大家在阅读源码时需要细细斟酌。

## 2.4　对象头

​	我们都知道Java语言是多态，那么如何实现多态？C++语言本身支持多态调用，众所周知，C++完成多态依赖于一个指针：虚指针（virtualpointer），这个指针指向一个虚表（virtualtable），这个虚表里面存储的是虚函数的地址，而这些函数的地址是在C++代码编译时确定的，通常虚表位于程序的数据段（Data Segment）中。

​	因为Java代码首先被翻译成字节码（bytecode），在JVM执行时才能确定要执行函数的地址，如何实现Java的多态调用，最直观的想法是把Java对象映射成C++对象或者封装成C++对象，比如增加一个额外的对象头，里面指向一个对象，而这个对象存储了Java代码的地址。所以JVM设计了对象的数据结构来描述Java对象，这个结构分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。而我们刚才提到的类似虚指针的东西就可以放在对象头中，而JVM设计者还利用对象头来描述更多信息，对象的锁信息、GC标记信息等。我们这里只讨论和G1相关的信息，更多信息大家可以参考其他书籍或者文章。

![](https://pic.imgdb.cn/item/62723a570947543129fcaff7.jpg)

**1.标记信息**

第一部分标记信息位于MarkOop。

根据JVM源码的注释，针对标记信息在32位JVM用32位来描述，我们可以总结出这32位的组合情况，如表2-1所示。

![](https://pic.imgdb.cn/item/62723a830947543129fd1f90.jpg)

另外在源代码中我们还看到一个Promoted的状态，Promoted指的是对象从新生代晋升到老生代时，正常的情况需要对这个对象头进行保存，主要的原因是如果发生晋升失败，需要重新恢复对象头。如果晋升成功这个保存的对象头就没有意义。所以为了提高晋升失败时对象头的恢复效率，设计了promo_bits，这个其实是重用了加锁位（包括偏向锁），实际上只需要在以下三种情况时才需要保存对象头：

* 使用了偏向锁，并且偏向锁被设置了。
* 对象被加锁了。
* 对象设置了hash_code。

这里和GC直接相关的就是标记位11，前面的30位指针是非常有用的。在GC垃圾回收时，当对象被设置为marked（11）时，ptr指向什么位置？简单来说这个ptr是为了配合对象晋升时发生的对象复制（copy）。在对象复制时，先分配空间，再把原来对象的所有数据都复制过去，再修改对象引用的指针，就完成了。但是我们要思考这样一个问题，当有多个引用对象的字段指向同一个被引用对象时，我们完成一个被引用对象的复制之后，其他引用对象还没有被遍历（即还指向被引用对象老的地址），如何处理这种情况？这个时候简单设置状态为marked，表示被引用对象已经被标记且被复制了，ptr就是指向新的复制的地址。当遍历其他引用对象的时候，发现被引用对象已经完成标记，则不再需要复制对象，直接完成对象引用更新就可以了。我们在讲述垃圾回收的时候会通过示意图再帮助大家巩固理解这个字段的意义。

**2.元数据信息**

​	第二部分元数据信息字段指向的是Klass对象（Klass对象是元数据对象，如Instance Klass描述Java对象的类结构），这个字段也和垃圾回收有关系。

​	这里大家先思考一个问题，就是在垃圾回收的时候如何区别一个立即数和指针地址？比如从Java的根集合中发现有一个值（如：0X12345678），那么这个数到底是一个整数还是一个Java对象的地址？实际上垃圾回收器不能区别，但是为了准确地回收垃圾，必须区别出来。一个简单的办法就是，把0X12345678先看成一个地址，即强制转换成OOP结构，再判定这个OOP是否是含有Klass指针，如果有的话即认为是一个指针，如果是NULL的话则认为是一个立即数。那么这里会有一个误判，即把一个立即数识别成一个OOP，当这个立即数刚好和一个OOP的地址相同的时候。所以JVM维护了一个全局的OOpMap，用于标记栈里面的数是立即数还是值。每一个InstanceKlass都维护了一个Map（OopMapBlock）用于标记Java类里面的字段到底是OOP还是int这样的立即数类型。这里面的字段Klass很多时候用于再次确认。

​	由此可见，可以从根集合出发开始标记，通过外部的数据结构来标识是否为OOP对象。但是我们在JVM源码中还是看到了很多地方会根据对象头里面的Klass指针是否为NULL来判断是不是OOP对象，这似乎是多此一举。理论上根据额外的数据结构已经不需要再次判断，但是在垃圾回收的时候，通常是对整个区域的一块内存进行完全遍历，在对象分配时都是连续分配，当堆的尾部有尚未分配对象的时候，比如在新生代一个字通常初始化为0x20202020，需要对这些空白地址进行转换以判断是否为OOP，是否需要垃圾回收。在这里即使误判影响也不大，因为会根据RSet来判定是否为活跃对象（live object），如果是的话继续，即使误判之后也没关系，这相当于是浮动垃圾，在下一次回收的时候仍然可能被回收。

## 2.5　内存分配和管理

​	首先JVM先通过操作系统的系统调用（systemcall）进行内存的申请，典型的就是mmap。在这里提一个问题，众所周知glibc提供了我们常用的内存管理函数如malloc/free/realloc/memcopy/memset等。为什么JVM不直接使用这些函数？glibc里面的malloc也是通过mmap等系统调用来完成内存的分配，之后glibc再对已经分配到的内存进行管理。GC算法实现了一套自己的管理方式，所以再基于malloc/free实现效率肯定不高。mmap必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。还要注意一点，操作系统对内存的分配管理典型地分为两个阶段：保留（reserve）和提交（commit）。保留阶段告知系统从某一地址开始到后面的dwSize大小的连续虚拟内存需要供程序使用，进程其他分配内存的操作不得使用这段内存；提交阶段将虚拟地址映射到对应的真实物理内存中，这样这块内存就可以正常使用。

​	对于保留和提交，Windows在使用VirtualAlloc分配内存时传递不同的参数MEM_RESERVE/MEM_COMMIT，Linux在mmap保留内存时使用MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS，提交内存时使用MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS。其中MAP_NORESERVE指不要为这个映射保留交换空间，MAP_FIXED使用指定的映射起始地址。

​	在JVM中我们还看到了使用类库函数malloc/free的地方。这和JVM内存管理策略有关，JVM内部也有很多数据需要在堆中分配，而这和Java堆空间没有关系，所以直接使用类库函数。另外需要提一下JVM推荐使用jemalloc替代glibc，原因是其效率更高。

JVM中常见的对象类型有以下6种：

* ResourceObj：线程有一个资源空间（ResourceArea），一般ResourceObj都位于这里。定义资源空间的目的是对JVM其他功能的支持，如CFG、在C1/C2优化时可能需要访问运行时信息（这些信息可以保存在线程的资源区）。
* StackObj：栈对象，声明的对象使用栈管理。其实栈对象并不提供任何功能，且禁止New/Delete操作。对象分配在线程栈中，或者使用自定义的栈容器进行管理。
* ValueObj：值对象，该对象在堆对象需要进行嵌套时使用，简单地说就是对象分配的位置和宿主对象（即拥有这个ValueObj对象的对象）是一样的。
* AllStatic：静态对象，全局对象，只有一个。值得一提的是C++中静态对象的初始化并没有通过规范保证，可能会有一个问题，就是两个静态对象相互依赖，那么在初始化的时候可能出错。JVM中的很多静态对象的初始化，都是显式调用静态初始化函数。
* MetaspaceObj：元对象，比如InstanceKlass这样的元数据就是元对象。
* CHeapObj：这是堆空间的对象，由new/delete/free/malloc管理。其包含的内容很多，比如Java对象、InstanceOop（后面提到的G1对象分配出来的对象）。除了Java对象，还有其他的对象也在堆中。

JVM中为了准确描述这些堆中的对象，以方便对JVM进行优化，所以又定义了更具体的子类型，代码如下所示：

![](https://pic.imgdb.cn/item/62723bc0094754312900373d.jpg)

![](https://pic.imgdb.cn/item/62723bcc0947543129006162.jpg)

​	这些信息描述了JVM使用内存的情况，这一部分信息能够帮助定位JVM本身运行时出现的问题，我们将在最后的附录B中通过本地内存跟踪（NativeMemory Tracking）来进一步解读这些信息。

## 2.6　线程

![](https://pic.imgdb.cn/item/62723be40947543129009f38.jpg)

* JavaThread：就是要执行Java代码的线程，比如Java代码的启动会创建一个JavaThread运行；对于Java代码的启动，可以通过JNI_CreateJavaVM[插图]来创建一个JavaThread，而对于一般的Java线程，都是调用java.lang.thread中的start方法，这个方法通过JNI调用创建JavaThread对象，完成真正的线程创建。
* CompilerThread：执行JIT的线程。
* WatcherThread：执行周期性任务，JVM里面有很多周期性任务，例如内存管理中对小对象使用了ChunkPool，而这种管理需要周期性的清理动作ChunkPool Cleaner；JVM中内存抽样任务MemProfilerTask等都是周期性任务。
* NameThread：是JVM内部使用的线程，分类如图2-1所示。VMThread：JVM执行GC的同步线程，这个是JVM最关键的线程之一，主要是用于处理垃圾回收。简单地说，所有的垃圾回收操作都是从VMThread触发的，如果是多线程回收，则启动多个线程，如果是单线程回收，则使用VMThread进行。VMThread提供了一个队列，任何要执行GC的操作都实现了VM_GC_Operation，在JavaThread中执行VMThread::execute(VM_GC_Operation)把GC操作放入到队列中，然后再用VMThread的run方法轮询这个队列就可以了。当这个队列有内容的时候它就开始尝试进入安全点，然后执行相应的GC任务，完成GC任务后会退出安全点。
* ConcurrentGCThread：并发执行GC任务的线程，比如G1中的ConcurrentMark Thread和ConcurrentG1RefineThread，分别处理并发标记和并发Refine，这两个线程将在混合垃圾收集和新生代垃圾回收中介绍。
* WorkerThread：工作线程，在G1中使用了FlexibleWorkGang，这个线程是并行执行的（个数一般和CPU个数相关），所以可以认为这是一个线程池。线程池里面的线程是为了执行任务（在G1中是G1ParTask），也就是做GC工作的地方。VMThread会触发这些任务的调度执行（其实是把G1ParTask放入到这些工作线程中，然后由工作线程进行调度）。



​	从线程的实现角度来看，JVM中的每一个线程都对应一个操作系统（OS）线程。JVM为了提供统一的处理，设计了JVM线程状态，代码如下所示：



### 2.6.1　栈帧

​	栈帧也是和GC密切相关的，在GC过程中，通常第一步就是遍历根，Java线程栈帧就是根元素之一，遍历整个栈帧的方式是通过StackFrameStream，其中封装了一个next指针，其原理和上述的代码一样，通过sender获得调用者的栈帧。

### 2.6.2　句柄

## 2.8　参数介绍和调优

* 参数G1HeapRegionSize指定堆分区大小。分区大小可以指定，也可以不指定；不指定时，由内存管理器启发式推断分区大小。
* 参数xms/xmx指定堆空间的最小值/最大值。一定要正确设置xms/xmx，否则将使用默认配置，将影响分区大小推断。
* 在以前的内存管理器中（非G1），为了防止新生代因为内存不断地重新分配导致性能变低，通常设置Xmn或者NewRatio。**但是G1中不要设置MaxNewSize、NewSize、Xmn和NewRatio**。原因有两个，第一G1对内存的管理不是连续的，所以即使重新分配一个堆分区代价也不高，第二也是最重要的，G1的目标满足垃圾收集停顿，这需要G1根据停顿时间动态调整收集的分区，如果设置了固定的分区数，即G1不能调整新生代的大小，那么G1可能不能满足停顿时间的要求。具体情况本书后续还会继续讨论。
* 参数GCTimeRatio指的是GC与应用程序之间的时间占比，默认值为9[插图]，表示GC与应用程序时间占比为10%。增大该值将减少GC占用的时间，带来的后果就是动态扩展内存更容易发生；在很多情况下10%已经很大，例如可以将该值设置为19，则表示GC时间不超过5%。
* **根据业务请求变化的情况**，设置合适的扩展G1ExpandByPercentOfAvailable速率，保持效率。
* JVM在对新生代内存分配管理时，还有一个参数就是保留内存G1ReservePercent（默认值是10），即在初始化，或者内存扩展/收缩的时候会计算更新有多少个分区是保留的，在新生代分区初始化的时候，在空闲列表中保留一定比例的分区不使用，那么在对象晋升的时候就可以使用了，所以能有效地减小晋升失败的概率。这个值最大不超过50，即最多保留50%的空间，但是保留过多会导致新生代可用空间少，过少可能会增加新生代晋升失败，那将会导致更为复杂的串行回收。

* G1NewSizePercent是一个实验参数，需要使用-XX:+UnlockExperimentalVMOptions才能改变选项。有实验表明G1在回收Eden分区的时候，大概每GB需要100ms，所以可以根据停顿时间，相应地调整。这个值在内存比较大的时候需要减少，例如32G可以设置-XX:G1NewSizePercent=3，这样Eden至少保留大约1GB的空间，从而保证收集效率。

* 参数MaxGCPauseMillis指期望停顿时间，**可根据系统配置和业务动态调整**。因为G1在垃圾收集的时候一定会收集新生代，所以需要配合新生代大小的设置来确定，如果该值太小，连新生代都不能收集完成，则没有任何意义，每次除了新生代之外只能多收集一个额外老生代分区。
* 参数GCPauseIntervalMillisGC指GC间隔时间，默认值为0，GC启发式推断为MaxGCPauseMillis+1，设置该值必须要大于MaxGCPauseMillis。
* 参数G1ConfidencePercent指GC预测置信度，该值越小说明基于过去历史数据的预测越准确，例如设置为0则表示收集的分区基本和过去的衰减均值相关，无波动，所以可以根据过去的衰减均值直接预测下一次预测的时间。反之该值越大，说明波动越大，越不准确，需要加上衰减方差来补偿。

* JVM中提供了一个对象对齐的值ObjectAlignmentInBytes，默认值为8，需要明白该值对内存使用的影响，这个影响不仅仅是在JVM对对象的分配上面，正如上面看到的它也会影响对象在分配时的标记情况。注意这个值最少要和操作系统支持的位数一致才能提高对象分配的效率。所以32位系统最少是4，64位最少是8。**一般不用修改该值。**

# 3. G1的对象分配

​	本章主要介绍G1的对象分配是怎样的。大体来说G1提供了两种对象分配策略：基于线程本地分配缓冲区（Thread Local Allocation Buffer，TLAB）的快速分配和慢速分配；当不能成功分配对象时就会触发垃圾回收，所以本章还总结了垃圾回收触发的时机；最后介绍了对象分配过程中涉及的参数调优。值得注意的是本章介绍的内容不仅适用于G1的对象分配，大多数调优参数也适用于其他的垃圾回收器。

## 3.1　对象分配概述

​	为了提高效率，无论快速分配还是慢速分配，都应该在STW之外调用，即都应该尽量避免使用全局锁，最好满足不同Mutator之间能并行分配且无干扰。但实际上堆空间只有一个，所以JVM的设计者致力于优秀的内存分配算法，把内存分配算法设计成几个层次，首先进行无锁分配，再进行加锁，从而尽可能地满足并行化分配。

![](https://pic.imgdb.cn/item/62723ef6094754312908324c.jpg)

## 3.2 快速分配

​	TLAB产生的目的就是为了进行内存快速分配。通常来说，JVM堆是所有线程的共享区域。因此，从JVM堆空间分配对象时，必须锁定整个堆，以便不会被其他线程中断和影响。为了解决这个问题，TLAB试图通过为每个线程分配一个缓冲区来避免和减少使用锁。

​	在分配线程对象时，从JVM堆中分配一个固定大小的内存区域并将其作为线程的私有缓冲区，这个缓冲区称为TLAB。只有在为每个线程分配TLAB缓冲区时才需要锁定整个JVM堆。由于TLAB是属于线程的，不同的线程不共享TLAB，当我们尝试分配一个对象时，优先从当前线程的TLAB中分配对象，不需要锁，因此达到了快速分配的目的。

​	更进一步地讲，实际上TLAB是Eden区域中的一块内存，不同线程的TLAB都位于Eden区，所有的TLAB内存对所有的线程都是可见的，只不过每个线程有一个TLAB的数据结构，用于保存待分配内存区间的起始地址（start）和结束地址（end），在分配的时候只在这个区间做分配，从而达到无锁分配，快速分配。

​	更进一步地讲，实际上TLAB是Eden区域中的一块内存，不同线程的TLAB都位于Eden区，所有的TLAB内存对所有的线程都是可见的，只不过每个线程有一个TLAB的数据结构，用于保存待分配内存区间的起始地址（start）和结束地址（end），在分配的时候只在这个区间做分配，从而达到无锁分配，快速分配。

![](https://pic.imgdb.cn/item/62723f8209475431290996db.jpg)

​	从TLAB已分配的缓冲区空间直接分配对象，也称为指针碰撞法分配，其方法非常简单，在TLAB中保存一个top指针用于标记当前对象分配的位置，如果剩余空间（end-top）大于待分配对象的空间（objSize），则直接修改top=top+ObjSize，相关代码位于thread->tlab().allocate(size)中。对于分配失败，处理稍微麻烦一些，相关代码位于allocate_from_tlab_slow()中，在学习这部分代码之前，先思考一下这样的内存分配管理该如何设计。

​	如果TLAB过小，那么TLAB则不能存储更多的对象，所以可能需要不断地重新分配新的TLAB。但是如果TLAB过大，则可能导致内存碎片问题。假设TLAB大小为1M，Eden为200M。如果有40个线程，每个线程分配1个TLAB，TLAB被填满之后，发生GC。假设TLAB中对象分配符合均匀分布，那么发生GC时，TLAB总的大小为：40×1×0.5=20M（Eden的10%左右），这意味着Eden还有很多空间时就发生了GC，这并不是我们想要的。最直观的想法是增加TLAB的大小或者增加线程的个数，这样TLAB在分配的时候效率会更高，但是在GC回收的时候则可能花费更长的时间。因此JVM提供了参数TLABSize用于控制TLAB的大小，如果我们设置了这个值，那么JVM就会使用这个值来初始化TLAB的大小。但是这样设置不够优雅，其实TLABSize默认值是0，也就是说JVM会推断这个值多大更合适。采用的参数为TLABWasteTargetPercent，用于设置TLAB可占用的Eden空间的百分比，默认值1%，推断方式为TLABSize=Eden×2×1%/线程个数（乘以2是因为假设其内存使用服从均分布）。

​	简单来说，tlab_capacity就是Eden所有可用的区域。另外要注意的是，这里采用的启发式推断也仅仅是一个近似值，实际上线程在使用内存分配对象时并不是无关的（不完全服从均匀分布），另外不同的线程类型对内存的使用也不同，比如一些调度线程、监控线程等几乎不会分配新的对象。

​	在Java对象分配时，我们总希望它位于TLAB中，如果TLAB满了之后，如何处理呢？前面提到TLAB其实就是Eden的一块区域，在G1中就是HeapRegion的一块空闲区域。所以TLAB满了之后无须做额外的处理，直接保留这一部分空间，重新在Eden/堆分区中分配一块空间给TLAB，然后再在TLAB分配具体的对象。但这里会有两个小问题。

**1.如何判断TLAB满了？**

​	按照前面的例子TLAB是1M，当我们使用800K，还是900K，还是950K时被认为满了？问题的答案是如何寻找最大的可能分配对象和减少内存碎片的平衡。实际上虚拟机内部会维护一个叫做refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，若小于该值，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste，在我们的这个例子中，refill_waste的初始值为16K，即TLAB中还剩（1M-16k=1024-16=1008K）1008K内存时直接分配一个新的，否则尽量使用这个老的TLAB。

**2.如何调整TLAB**

​	如果要分配的内存大于TLAB剩余的空间则直接在Eden/HeapRegion中分配。那么这个1/64是否合适？会不会太小，比如通常分配的对象大多是20K，最后剩下16K，这样导致每次都进入Eden/堆分区慢速分配中。所以，JVM还提供了一个参数TLAB WasteIncrement（默认值为4个字）用于动态增加这个refill_waste的值。默认情况下，TLAB大小和refill_waste都会在运行时不断调整，使系统的运行状态达到最优。在动态调整的过程中，也不能无限制变更，所以JVM提供MinTLABSize（默认值2K）用于控制最小值，对于G1来说，由于大对象都不在新生代分区，所以TLAB也不能分配大对象，HeapRegion/2就会被认定为大对象，所以TLAB肯定不会超过HeapRegionSize的一半。

​	如果想要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB禁用ResizeTLAB，并使用-XX:TLABSize手工指定一个TLAB的大小。-XX:+PrintTLAB可以跟踪TLAB的使用情况。一般不建议手工修改TLAB相关参数，**推荐使用虚拟机默认行为**。

* TLAB的剩余空间是否太小，如果很小，即说明这个空间通常不满足对象的分配，所以最好丢弃，丢弃的方法就是填充一个dummy对象，然后申请新的TLAB来分配对象。
* 如果不能丢弃，说明TLAB剩余空间并不小，能满足很多对象的分配，所以不能丢弃这个TLAB，否则内存浪费很多，此时可以把对象分配到堆中，不使用TLAB分配，所以可以直接返回。

![](https://pic.imgdb.cn/item/627240a209475431290c6b44.jpg)

**图3-3　申请TLAB分区和对象慢速分配流程图**

​	快速无锁分配：指的是在当前可以分配的堆分区中使用CAS来获取一块内存，如果成功则可以作为TLAB的空间。因为使用CAS可以并行分配，当然也有可能不成功。对于不成功则进行慢速分配。

​	对于不成功则进行慢速分配，慢速分配需要尝试对Heap加锁，扩展新生代区域或垃圾回收等处理后再分配。

**日志及解读**

![](https://pic.imgdb.cn/item/627240f309475431290d33bf.jpg)

![](https://pic.imgdb.cn/item/6272410009475431290d5d19.jpg)

​	对于多线程的情况，这里还会有每个线程的输出结果以及一个总结信息。由于篇幅的关系此处都已经省略。下面我们分析日志中TLAB这个信息的每一个字段含义：

* desired_size为期望分配的TLAB的大小，这个值就是我们前面提到如何计算TLABSize的方式。在这个例子中，第一次的时候，不知道会有多少线程，所以初始化为1，desired_size=24576/50=491.5KB这个值是经过取整的。
* slow allocs为发生慢速分配的次数，日志中显示有8次分配到heap而没有使用TLAB。
* refill waste为retire一个TLAB的阈值。
* alloc为该线程在堆分区分配的比例。
* refills发生的次数，这里是50，表示从上一次GC到这次GC期间，一共retire过50个TLAB块，在每一个TLAB块retire的时候都会做一次refill把尚未使用的内存填充为dummy对象。
* waste由3个部分组成：
  * gc：发生GC时还没有使用的TLAB的空间。
  * slow：产生新的TLAB时，旧的TLAB浪费的空间，这里就是新生成50个TLAB，浪费了816个字节。
  * fast：指的是在C1中，发生TLAB retire（产生新的TLAB）时，旧的TLAB浪费的空间。

